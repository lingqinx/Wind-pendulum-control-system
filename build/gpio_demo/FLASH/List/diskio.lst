###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      15/Aug/2015  19:53:01 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\d #
#                    iskio\diskio.c                                           #
#    Command line =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\d #
#                    iskio\diskio.c -lCN C:\Users\Administrator\Desktop\MPU60 #
#                    508.12\build\gpio_demo\FLASH\List\ -lB                   #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\ -o C:\Users\Administrator\Desktop\MPU6050 #
#                    8.12\build\gpio_demo\FLASH\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\IAR Systems\Embedded     #
#                    Workbench 6.5\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\ -I C:\Users\Administrator\Desktop\MPU60508.12\bui #
#                    ld\gpio_demo\..\..\src\common\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\cpu\ -I C:\Users\Administrator\Desktop\MPU6 #
#                    0508.12\build\gpio_demo\..\..\src\drivers\ -I            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\gpio\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\olcd\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\diskio\ -I                          #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\iospi\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\wdog\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\mcg\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\uart\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\lptmr\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\LED\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\fun\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\FTM\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\pit\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\DIPswitch\ -I                       #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\motor\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\laser\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\i2c\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\ADdevice\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\adc\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\serial_digtal_scope\ -I             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MMA845x\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\exti\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\dma\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\platforms\ -I C:\Users\Administrator\Deskto #
#                    p\MPU60508.12\build\gpio_demo\..\..\src\projects\ -I     #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\projects\gpio_demo\ -I                      #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MPU6050\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -Ol                          #
#    List file    =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\diskio.lst                                 #
#    Object file  =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\Obj\diskio.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\diskio\diskio.c
      1          //=========================================================================
      2          // 文件名称：diskio.h
      3          // 功能概要：diskio构件源文件
      4          // 版权所有: 苏州大学飞思卡尔嵌入式中心(sumcu.suda.edu.cn)
      5          // 版本更新:  2011-12-14     V1.0        diskio构件初始版本
      6          //           2011-12-20     V1.1        diskio构件优化修改
      7          //=========================================================================
      8          #include "K60_datatype.h"
      9          #include "common.h"
     10          #include "include.h"

   \                                 In section .bss, align 4
     11          SDCARD_STRUCT SDHC_Card;
   \                     SDHC_Card:
   \   00000000                      DS8 24
     12          
     13          //SD卡状态属性访问器

   \                                 In section .data, align 1
     14          static volatile unsigned char Stat   = STA_NOINIT; //保存SD卡状态
   \                     Stat:
   \   00000000   0x01               DC8 1

   \                                 In section .text, align 2, keep-with-next
     15          u8 GetCardStat(void) { return Stat; }
   \                     GetCardStat: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     16          void SetCardStat(u8 state) { Stat = state; }
   \                     SetCardStat: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
     17          

   \                                 In section .bss, align 4
     18          static volatile unsigned int  Timer = 0; //读写时间
   \                     Timer:
   \   00000000                      DS8 4
     19          
     20          //=========================================================================
     21          //函数名称：disk_initialize
     22          //功能概要：初始化数据盘（只支持数据盘0） 
     23          //参数说明：drv:设备号
     24          //函数返回：RES_OK：成功；其它：失败
     25          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
     26          DRESULT disk_initialize (unsigned char drv)
     27          {
   \                     disk_initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
     28              u32  param, c_size, c_size_mult, read_bl_len;
     29              ESDHC_COMMAND_STRUCT  command;
     30              SDCARD_STRUCT_PTR     sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable11_1
     31          
     32              //检查参数
     33              if (drv || (NULL == sdcard_ptr)) return RES_PARERR; //仅仅支持设备0
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??disk_initialize_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD101             BNE.N    ??disk_initialize_1
   \                     ??disk_initialize_0: (+1)
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE10E             B.N      ??disk_initialize_2
     34              //检查卡插入状态
     35              if (Stat & STA_NODISK) return RES_NOTRDY; //SD卡未插入
   \                     ??disk_initialize_1: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD501             BPL.N    ??disk_initialize_3
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0xE107             B.N      ??disk_initialize_2
     36          
     37              //初始化SD卡设备登记信息
     38              sdcard_ptr->BITS = ESDHC_BUS_WIDTH_4BIT;//设置位宽为4位
   \                     ??disk_initialize_3: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x6060             STR      R0,[R4, #+4]
     39              sdcard_ptr->SD_TIMEOUT = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x60A0             STR      R0,[R4, #+8]
     40              sdcard_ptr->NUM_BLOCKS = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x60E0             STR      R0,[R4, #+12]
     41              sdcard_ptr->ADDRESS    = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6160             STR      R0,[R4, #+20]
     42              sdcard_ptr->SDHC       = FALSE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7420             STRB     R0,[R4, #+16]
     43              sdcard_ptr->VERSION2   = FALSE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7460             STRB     R0,[R4, #+17]
     44          
     45              //检测并初始化SD卡
     46              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_INIT, NULL))
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       SDHC_ioctl
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ.N    ??disk_initialize_4
     47                  return RES_ERROR;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE0F3             B.N      ??disk_initialize_2
     48          
     49              //获取SD卡类型
     50              param = 0;
   \                     ??disk_initialize_4: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9000             STR      R0,[SP, #+0]
     51              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_GET_CARD, &param))
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x.... 0x....      BL       SDHC_ioctl
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??disk_initialize_5
     52                  return RES_ERROR;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE0E9             B.N      ??disk_initialize_2
     53              if (    (ESDHC_CARD_SD == param) 
     54                   || (ESDHC_CARD_SDHC == param) 
     55                   || (ESDHC_CARD_SDCOMBO == param) 
     56                   || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_5: (+1)
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD008             BEQ.N    ??disk_initialize_6
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x2803             CMP      R0,#+3
   \   0000006A   0xD005             BEQ.N    ??disk_initialize_6
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x2805             CMP      R0,#+5
   \   00000070   0xD002             BEQ.N    ??disk_initialize_6
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x2806             CMP      R0,#+6
   \   00000076   0xD12F             BNE.N    ??disk_initialize_7
     57              {
     58                  if ((ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_6: (+1)
   \   00000078   0x9800             LDR      R0,[SP, #+0]
   \   0000007A   0x2803             CMP      R0,#+3
   \   0000007C   0xD002             BEQ.N    ??disk_initialize_8
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x2806             CMP      R0,#+6
   \   00000082   0xD101             BNE.N    ??disk_initialize_9
     59                  {
     60                      sdcard_ptr->SDHC = TRUE;
   \                     ??disk_initialize_8: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x7420             STRB     R0,[R4, #+16]
     61                  }
     62              }
     63              else
     64                  return RES_PARERR;
     65          
     66              //SD卡标识
     67              command.COMMAND  = ESDHC_CMD2;
   \                     ??disk_initialize_9: (+1)
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0xF88D 0x0004      STRB     R0,[SP, #+4]
     68              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xF88D 0x0005      STRB     R0,[SP, #+5]
     69              command.ARGUMENT = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x9002             STR      R0,[SP, #+8]
     70              command.READ     = FALSE;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF88D 0x000C      STRB     R0,[SP, #+12]
     71              command.BLOCKS   = 0;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x9004             STR      R0,[SP, #+16]
     72              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000A2   0xA901             ADD      R1,SP,#+4
   \   000000A4   0x2002             MOVS     R0,#+2
   \   000000A6   0x.... 0x....      BL       SDHC_ioctl
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD116             BNE.N    ??disk_initialize_10
     73                  return RES_ERROR;
     74          
     75              //获取SD卡地址
     76              command.COMMAND  = ESDHC_CMD3;
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xF88D 0x0004      STRB     R0,[SP, #+4]
     77              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF88D 0x0005      STRB     R0,[SP, #+5]
     78              command.ARGUMENT = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x9002             STR      R0,[SP, #+8]
     79              command.READ     = FALSE;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF88D 0x000C      STRB     R0,[SP, #+12]
     80              command.BLOCKS   = 0;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x9004             STR      R0,[SP, #+16]
     81              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000C8   0xA901             ADD      R1,SP,#+4
   \   000000CA   0x2002             MOVS     R0,#+2
   \   000000CC   0x.... 0x....      BL       SDHC_ioctl
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD005             BEQ.N    ??disk_initialize_11
     82                  return RES_ERROR;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0xE0AD             B.N      ??disk_initialize_2
   \                     ??disk_initialize_7: (+1)
   \   000000D8   0x2004             MOVS     R0,#+4
   \   000000DA   0xE0AB             B.N      ??disk_initialize_2
   \                     ??disk_initialize_10: (+1)
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xE0A9             B.N      ??disk_initialize_2
     83              sdcard_ptr->ADDRESS = command.RESPONSE[0] & 0xFFFF0000;
   \                     ??disk_initialize_11: (+1)
   \   000000E0   0x9805             LDR      R0,[SP, #+20]
   \   000000E2   0x0C00             LSRS     R0,R0,#+16
   \   000000E4   0x0400             LSLS     R0,R0,#+16
   \   000000E6   0x6160             STR      R0,[R4, #+20]
     84              
     85              //获取SD卡读写属性参数
     86              command.COMMAND  = ESDHC_CMD9;
   \   000000E8   0x2009             MOVS     R0,#+9
   \   000000EA   0xF88D 0x0004      STRB     R0,[SP, #+4]
     87              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xF88D 0x0005      STRB     R0,[SP, #+5]
     88              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000F4   0x6960             LDR      R0,[R4, #+20]
   \   000000F6   0x9002             STR      R0,[SP, #+8]
     89              command.READ     = FALSE;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF88D 0x000C      STRB     R0,[SP, #+12]
     90              command.BLOCKS   = 0;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9004             STR      R0,[SP, #+16]
     91              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000102   0xA901             ADD      R1,SP,#+4
   \   00000104   0x2002             MOVS     R0,#+2
   \   00000106   0x.... 0x....      BL       SDHC_ioctl
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD001             BEQ.N    ??disk_initialize_12
     92                  return RES_ERROR;
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xE090             B.N      ??disk_initialize_2
     93              if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??disk_initialize_12: (+1)
   \   00000112   0x9808             LDR      R0,[SP, #+32]
   \   00000114   0xF410 0x0F40      TST      R0,#0xC00000
   \   00000118   0xD119             BNE.N    ??disk_initialize_13
     94              {
     95                  read_bl_len = (command.RESPONSE[2] >> 8) & 0x0F;
   \   0000011A   0x9807             LDR      R0,[SP, #+28]
   \   0000011C   0xF3C0 0x2203      UBFX     R2,R0,#+8,#+4
     96                  c_size = command.RESPONSE[2] & 0x03;
   \   00000120   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   00000124   0xF010 0x0003      ANDS     R0,R0,#0x3
     97                  c_size = (c_size << 10) | (command.RESPONSE[1] >> 22);
   \   00000128   0x9906             LDR      R1,[SP, #+24]
   \   0000012A   0x0D89             LSRS     R1,R1,#+22
   \   0000012C   0xEA51 0x2080      ORRS     R0,R1,R0, LSL #+10
     98                  c_size_mult = (command.RESPONSE[1] >> 7) & 0x07;
   \   00000130   0x9906             LDR      R1,[SP, #+24]
   \   00000132   0xF3C1 0x11C2      UBFX     R1,R1,#+7,#+3
     99                  sdcard_ptr->NUM_BLOCKS = (c_size+1)*(1<<(c_size_mult+2))*(1<<(read_bl_len-9));
   \   00000136   0x1C40             ADDS     R0,R0,#+1
   \   00000138   0x2301             MOVS     R3,#+1
   \   0000013A   0x1C89             ADDS     R1,R1,#+2
   \   0000013C   0xFA13 0xF101      LSLS     R1,R3,R1
   \   00000140   0x4348             MULS     R0,R1,R0
   \   00000142   0x2101             MOVS     R1,#+1
   \   00000144   0x3A09             SUBS     R2,R2,#+9
   \   00000146   0x4091             LSLS     R1,R1,R2
   \   00000148   0x4348             MULS     R0,R1,R0
   \   0000014A   0x60E0             STR      R0,[R4, #+12]
   \   0000014C   0xE007             B.N      ??disk_initialize_14
    100              }
    101              else
    102              {
    103                  sdcard_ptr->VERSION2 = TRUE;
   \                     ??disk_initialize_13: (+1)
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0x7460             STRB     R0,[R4, #+17]
    104                  c_size = (command.RESPONSE[1] >> 8) & 0x003FFFFF;
   \   00000152   0x9806             LDR      R0,[SP, #+24]
   \   00000154   0xF3C0 0x2015      UBFX     R0,R0,#+8,#+22
    105                  sdcard_ptr->NUM_BLOCKS = (c_size + 1) << 10;
   \   00000158   0x1C40             ADDS     R0,R0,#+1
   \   0000015A   0x0280             LSLS     R0,R0,#+10
   \   0000015C   0x60E0             STR      R0,[R4, #+12]
    106              }
    107          
    108              //选择SD卡
    109              command.COMMAND  = ESDHC_CMD7;
   \                     ??disk_initialize_14: (+1)
   \   0000015E   0x2007             MOVS     R0,#+7
   \   00000160   0xF88D 0x0004      STRB     R0,[SP, #+4]
    110              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0xF88D 0x0005      STRB     R0,[SP, #+5]
    111              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   0000016A   0x6960             LDR      R0,[R4, #+20]
   \   0000016C   0x9002             STR      R0,[SP, #+8]
    112              command.READ     = FALSE;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF88D 0x000C      STRB     R0,[SP, #+12]
    113              command.BLOCKS   = 0;
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x9004             STR      R0,[SP, #+16]
    114              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000178   0xA901             ADD      R1,SP,#+4
   \   0000017A   0x2002             MOVS     R0,#+2
   \   0000017C   0x.... 0x....      BL       SDHC_ioctl
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD001             BEQ.N    ??disk_initialize_15
    115                  return RES_ERROR;
   \   00000184   0x2001             MOVS     R0,#+1
   \   00000186   0xE055             B.N      ??disk_initialize_2
    116          
    117              //设置块大小
    118              command.COMMAND  = ESDHC_CMD16;
   \                     ??disk_initialize_15: (+1)
   \   00000188   0x2010             MOVS     R0,#+16
   \   0000018A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    119              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0xF88D 0x0005      STRB     R0,[SP, #+5]
    120              command.ARGUMENT = IO_SDCARD_BLOCK_SIZE;
   \   00000194   0xF44F 0x7000      MOV      R0,#+512
   \   00000198   0x9002             STR      R0,[SP, #+8]
    121              command.READ     = FALSE;
   \   0000019A   0x2000             MOVS     R0,#+0
   \   0000019C   0xF88D 0x000C      STRB     R0,[SP, #+12]
    122              command.BLOCKS   = 0;
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0x9004             STR      R0,[SP, #+16]
    123              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001A4   0xA901             ADD      R1,SP,#+4
   \   000001A6   0x2002             MOVS     R0,#+2
   \   000001A8   0x.... 0x....      BL       SDHC_ioctl
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD001             BEQ.N    ??disk_initialize_16
    124                  return RES_ERROR;
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0xE03F             B.N      ??disk_initialize_2
    125          
    126              if (ESDHC_BUS_WIDTH_4BIT == sdcard_ptr->BITS)
   \                     ??disk_initialize_16: (+1)
   \   000001B4   0x6860             LDR      R0,[R4, #+4]
   \   000001B6   0x2801             CMP      R0,#+1
   \   000001B8   0xD133             BNE.N    ??disk_initialize_17
    127              {
    128                  //发送特殊的命令CMD55
    129                  command.COMMAND  = ESDHC_CMD55;
   \   000001BA   0x2037             MOVS     R0,#+55
   \   000001BC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    130                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0xF88D 0x0005      STRB     R0,[SP, #+5]
    131                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000001C6   0x6960             LDR      R0,[R4, #+20]
   \   000001C8   0x9002             STR      R0,[SP, #+8]
    132                  command.READ     = FALSE;
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0xF88D 0x000C      STRB     R0,[SP, #+12]
    133                  command.BLOCKS  = 0;
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0x9004             STR      R0,[SP, #+16]
    134                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001D4   0xA901             ADD      R1,SP,#+4
   \   000001D6   0x2002             MOVS     R0,#+2
   \   000001D8   0x.... 0x....      BL       SDHC_ioctl
   \   000001DC   0x2800             CMP      R0,#+0
   \   000001DE   0xD001             BEQ.N    ??disk_initialize_18
    135                      return RES_ERROR;
   \   000001E0   0x2001             MOVS     R0,#+1
   \   000001E2   0xE027             B.N      ??disk_initialize_2
    136          
    137                  //设置数据位宽为4位
    138                  command.COMMAND = ESDHC_ACMD6;
   \                     ??disk_initialize_18: (+1)
   \   000001E4   0x2046             MOVS     R0,#+70
   \   000001E6   0xF88D 0x0004      STRB     R0,[SP, #+4]
    139                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0xF88D 0x0005      STRB     R0,[SP, #+5]
    140                  command.ARGUMENT = 2;
   \   000001F0   0x2002             MOVS     R0,#+2
   \   000001F2   0x9002             STR      R0,[SP, #+8]
    141                  command.READ = FALSE;
   \   000001F4   0x2000             MOVS     R0,#+0
   \   000001F6   0xF88D 0x000C      STRB     R0,[SP, #+12]
    142                  command.BLOCKS = 0;
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0x9004             STR      R0,[SP, #+16]
    143                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001FE   0xA901             ADD      R1,SP,#+4
   \   00000200   0x2002             MOVS     R0,#+2
   \   00000202   0x.... 0x....      BL       SDHC_ioctl
   \   00000206   0x2800             CMP      R0,#+0
   \   00000208   0xD001             BEQ.N    ??disk_initialize_19
    144                      return RES_ERROR;
   \   0000020A   0x2001             MOVS     R0,#+1
   \   0000020C   0xE012             B.N      ??disk_initialize_2
    145          
    146                  param = ESDHC_BUS_WIDTH_4BIT;
   \                     ??disk_initialize_19: (+1)
   \   0000020E   0x2001             MOVS     R0,#+1
   \   00000210   0x9000             STR      R0,[SP, #+0]
    147                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SET_BUS_WIDTH, &param))
   \   00000212   0xA900             ADD      R1,SP,#+0
   \   00000214   0x2007             MOVS     R0,#+7
   \   00000216   0x.... 0x....      BL       SDHC_ioctl
   \   0000021A   0x2800             CMP      R0,#+0
   \   0000021C   0xD001             BEQ.N    ??disk_initialize_17
    148                      return RES_ERROR;
   \   0000021E   0x2001             MOVS     R0,#+1
   \   00000220   0xE008             B.N      ??disk_initialize_2
    149              }
    150          
    151              Stat &= ~STA_NOINIT;//清除数据盘状态
   \                     ??disk_initialize_17: (+1)
   \   00000222   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000226   0x7800             LDRB     R0,[R0, #+0]
   \   00000228   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000230   0x7008             STRB     R0,[R1, #+0]
    152              
    153              return RES_OK;
   \   00000232   0x2000             MOVS     R0,#+0
   \                     ??disk_initialize_2: (+1)
   \   00000234   0xB00A             ADD      SP,SP,#+40
   \   00000236   0xBD10             POP      {R4,PC}          ;; return
    154          }
    155          
    156          //=========================================================================
    157          //函数名称：disk_read                                                        
    158          //功能概要：读数据盘扇区                                                
    159          //参数说明：drv:设备号
    160          //         buff:用于存储读取的数据的缓存区
    161          //         sector:起始扇区号
    162          //         count:扇区数
    163          //函数返回：RES_OK：成功，其它：失败                                                              
    164          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    165          DRESULT disk_read(u8 drv,u8 *buff,u32 sector, u32 count)
    166          {
   \                     disk_read: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x001D             MOVS     R5,R3
    167              ESDHC_COMMAND_STRUCT command;
    168              SDCARD_STRUCT_PTR    sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable11_1
    169                  
    170              //检查参数
    171              if (drv || !count) return RES_PARERR;
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??disk_read_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??disk_read_1
   \                     ??disk_read_0: (+1)
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE04B             B.N      ??disk_read_2
    172              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_read_1: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD501             BPL.N    ??disk_read_3
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xE044             B.N      ??disk_read_2
    173              if ((NULL == buff)) return RES_ERROR;
   \                     ??disk_read_3: (+1)
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD101             BNE.N    ??disk_read_4
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE040             B.N      ??disk_read_2
    174              
    175              if (!sdcard_ptr->SDHC)
   \                     ??disk_read_4: (+1)
   \   00000030   0x7C08             LDRB     R0,[R1, #+16]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD100             BNE.N    ??disk_read_5
    176                  //sector *= 512;//扇区号转化为起始地址
    177                  sector = sector << IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000036   0x0252             LSLS     R2,R2,#+9
    178          
    179              if (count == 1)//读单个扇区
   \                     ??disk_read_5: (+1)
   \   00000038   0x2D01             CMP      R5,#+1
   \   0000003A   0xD119             BNE.N    ??disk_read_6
    180              {
    181                  command.COMMAND  = ESDHC_CMD17;
   \   0000003C   0x2011             MOVS     R0,#+17
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    182                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF88D 0x0001      STRB     R0,[SP, #+1]
    183                  command.ARGUMENT = sector;
   \   00000048   0x9201             STR      R2,[SP, #+4]
    184                  command.READ     = TRUE;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF88D 0x0008      STRB     R0,[SP, #+8]
    185                  command.BLOCKS   = count;	
   \   00000050   0x9503             STR      R5,[SP, #+12]
    186          
    187                  if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000052   0xA900             ADD      R1,SP,#+0
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x.... 0x....      BL       SDHC_ioctl
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD123             BNE.N    ??disk_read_7
    188                  {
    189                      //if (hw_sdhc_receive_block(buff, 512))
    190                      if (SDHC_receive_block(buff, IO_SDCARD_BLOCK_SIZE))
   \   0000005E   0xF44F 0x7100      MOV      R1,#+512
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       SDHC_receive_block
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD01C             BEQ.N    ??disk_read_7
    191                          count = 0;
   \   0000006C   0x2500             MOVS     R5,#+0
   \   0000006E   0xE01A             B.N      ??disk_read_7
    192                  }
    193              }
    194              else //读多个扇区
    195              {     
    196                  command.COMMAND  = ESDHC_CMD18;
   \                     ??disk_read_6: (+1)
   \   00000070   0x2012             MOVS     R0,#+18
   \   00000072   0xF88D 0x0000      STRB     R0,[SP, #+0]
    197                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF88D 0x0001      STRB     R0,[SP, #+1]
    198                  command.ARGUMENT = sector;
   \   0000007C   0x9201             STR      R2,[SP, #+4]
    199                  command.READ     = TRUE;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF88D 0x0008      STRB     R0,[SP, #+8]
    200                  command.BLOCKS   = count;   
   \   00000084   0x9503             STR      R5,[SP, #+12]
    201          
    202                  if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000086   0xA900             ADD      R1,SP,#+0
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x.... 0x....      BL       SDHC_ioctl
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD109             BNE.N    ??disk_read_7
    203                  {
    204                      if (SDHC_receive_block(buff, IO_SDCARD_BLOCK_SIZE*count))
   \   00000092   0xF44F 0x7000      MOV      R0,#+512
   \   00000096   0xFB00 0xF105      MUL      R1,R0,R5
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       SDHC_receive_block
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD000             BEQ.N    ??disk_read_7
    205                          count = 0;
   \   000000A4   0x2500             MOVS     R5,#+0
    206                  }
    207              }
    208          
    209              return count ? RES_ERROR : RES_OK;
   \                     ??disk_read_7: (+1)
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0xD001             BEQ.N    ??disk_read_8
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xE000             B.N      ??disk_read_9
   \                     ??disk_read_8: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??disk_read_9: (+1)
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_read_2: (+1)
   \   000000B2   0xB009             ADD      SP,SP,#+36
   \   000000B4   0xBD30             POP      {R4,R5,PC}       ;; return
    210          }
    211          
    212          //=========================================================================
    213          //函数名称：disk_write                                                        
    214          //功能概要：写数据盘扇区                                                
    215          //参数说明：drv:设备号
    216          //         buff:待写入SD卡的数据的缓存区首地址
    217          //         sector:起始扇区号
    218          //         count:扇区数
    219          //函数返回：RES_OK：成功，其它：失败                                                              
    220          //=========================================================================
    221          

   \                                 In section .bss, align 4
    222          static SDCARD_STRUCT_PTR    sdcard_ptr;
   \                     sdcard_ptr:
   \   00000000                      DS8 4
    223          
    224          
    225          

   \                                 In section .text, align 2, keep-with-next
    226          DRESULT Pic_save_init(u8 drv,const u8 *buff,u32 sector,u32  count)
    227          {
   \                     Pic_save_init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001C             MOVS     R4,R3
    228            ESDHC_COMMAND_STRUCT command;
    229            sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable11_1
   \   00000010   0x6013             STR      R3,[R2, #+0]
    230            //检查参数
    231            if (drv || !count) return RES_PARERR;
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??Pic_save_init_0
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD101             BNE.N    ??Pic_save_init_1
   \                     ??Pic_save_init_0: (+1)
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0xE03C             B.N      ??Pic_save_init_2
    232            if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??Pic_save_init_1: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD501             BPL.N    ??Pic_save_init_3
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE035             B.N      ??Pic_save_init_2
    233            if (Stat & STA_PROTECT) return RES_WRPRT;
   \                     ??Pic_save_init_3: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x0740             LSLS     R0,R0,#+29
   \   00000036   0xD501             BPL.N    ??Pic_save_init_4
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE02E             B.N      ??Pic_save_init_2
    234            
    235            
    236            //检测缓存区是否为空
    237            if ((NULL == buff)) return RES_ERROR;
   \                     ??Pic_save_init_4: (+1)
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD101             BNE.N    ??Pic_save_init_5
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE02A             B.N      ??Pic_save_init_2
    238            if (!sdcard_ptr->SDHC)
   \                     ??Pic_save_init_5: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x7C00             LDRB     R0,[R0, #+16]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD100             BNE.N    ??Pic_save_init_6
    239              //sector *= 512;	//扇区号转化为起始地址
    240              sector = sector << IO_SDCARD_BLOCK_SIZE_POWER; 
   \   00000050   0x026D             LSLS     R5,R5,#+9
    241            
    242            
    243            command.COMMAND  = ESDHC_ACMD23;    //发送ACMD23命令，擦除扇区
   \                     ??Pic_save_init_6: (+1)
   \   00000052   0x2057             MOVS     R0,#+87
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    244            command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    245            command.ARGUMENT = sector;
   \   0000005E   0x9501             STR      R5,[SP, #+4]
    246            command.READ     = FALSE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF88D 0x0008      STRB     R0,[SP, #+8]
    247            command.BLOCKS   = count;
   \   00000066   0x9403             STR      R4,[SP, #+12]
    248            if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000068   0xA900             ADD      R1,SP,#+0
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       SDHC_ioctl
   \   00000070   0x0006             MOVS     R6,R0
    249            {
    250                    
    251          #if PRINT
    252                    uartPrintf("多扇区写入时扇区擦除成功\n");
    253          
    254          #endif
    255            }
    256            
    257            
    258            
    259            command.COMMAND  = ESDHC_CMD25;//发送CMD25命令，开始多块写扇区
   \   00000072   0x2019             MOVS     R0,#+25
   \   00000074   0xF88D 0x0000      STRB     R0,[SP, #+0]
    260            command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    261            command.ARGUMENT = sector;
   \   0000007E   0x9501             STR      R5,[SP, #+4]
    262            command.READ     = FALSE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF88D 0x0008      STRB     R0,[SP, #+8]
    263            command.BLOCKS   = count;
   \   00000086   0x9403             STR      R4,[SP, #+12]
    264            if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000088   0xA900             ADD      R1,SP,#+0
   \   0000008A   0x2002             MOVS     R0,#+2
   \   0000008C   0x.... 0x....      BL       SDHC_ioctl
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD101             BNE.N    ??Pic_save_init_7
    265            {
    266              
    267              return  RES_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE000             B.N      ??Pic_save_init_2
    268            }
    269            else
    270            {
    271              return  RES_ERROR;
   \                     ??Pic_save_init_7: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \                     ??Pic_save_init_2: (+1)
   \   0000009A   0xB008             ADD      SP,SP,#+32
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
    272            }
    273          }
    274          

   \                                 In section .text, align 2, keep-with-next
    275          DRESULT Pic_save(u8 *buffer)
    276          {
   \                     Pic_save: (+1)
   \   00000000   0xB410             PUSH     {R4}
    277            u16 i;
    278            u8 j=18;
   \   00000002   0x2212             MOVS     R2,#+18
    279            u32 *ptr = (u32*)buffer;
   \   00000004   0xE000             B.N      ??Pic_save_0
    280            //读取数据时，每次读取4个字节
    281            //bytes = btr;
    282            while(j)
    283            {
    284              i=512;
    285              for (i = (i + 3) >> 2; i != 0; i--)
    286              {
    287                if (SDHC_IRQSTAT & (    SDHC_IRQSTAT_DEBE_MASK 
    288                                            | SDHC_IRQSTAT_DCE_MASK 
    289                                            | SDHC_IRQSTAT_DTOE_MASK))
    290                {
    291                          SDHC_IRQSTAT    |= SDHC_IRQSTAT_DEBE_MASK 
    292                                          | SDHC_IRQSTAT_DCE_MASK 
    293                                          | SDHC_IRQSTAT_DTOE_MASK 
    294                                          | SDHC_IRQSTAT_BWR_MASK;
    295          #if PRINT
    296                           uartPrintf("错误返回1\n");
    297          #endif 
    298                           return 0;
    299                }
    300                while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
    301                {
    302                        
    303          #if PRINT
    304                        uartPrintf("等待数据\n");
    305          #endif
    306                }  //等待数据准备好
    307                SDHC_DATPORT = *ptr++;
    308              } 
    309              j--;
   \                     ??Pic_save_1: (+1)
   \   00000006   0x1E52             SUBS     R2,R2,#+1
   \                     ??Pic_save_0: (+1)
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD021             BEQ.N    ??Pic_save_2
   \   0000000E   0xF44F 0x7100      MOV      R1,#+512
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0x1CC9             ADDS     R1,R1,#+3
   \   00000016   0x1089             ASRS     R1,R1,#+2
   \   00000018   0xE009             B.N      ??Pic_save_3
   \                     ??Pic_save_4: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable11_3  ;; 0x400b1024
   \   0000001E   0x681B             LDR      R3,[R3, #+0]
   \   00000020   0x055B             LSLS     R3,R3,#+21
   \   00000022   0xD5FA             BPL.N    ??Pic_save_4
   \   00000024   0x....             LDR.N    R3,??DataTable11_4  ;; 0x400b1020
   \   00000026   0x6804             LDR      R4,[R0, #+0]
   \   00000028   0x601C             STR      R4,[R3, #+0]
   \   0000002A   0x1D00             ADDS     R0,R0,#+4
   \   0000002C   0x1E49             SUBS     R1,R1,#+1
   \                     ??Pic_save_3: (+1)
   \   0000002E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD0E8             BEQ.N    ??Pic_save_1
   \   00000034   0x....             LDR.N    R3,??DataTable11_5  ;; 0x400b1030
   \   00000036   0x681B             LDR      R3,[R3, #+0]
   \   00000038   0xF413 0x0FE0      TST      R3,#0x700000
   \   0000003C   0xD0ED             BEQ.N    ??Pic_save_4
   \   0000003E   0x....             LDR.N    R0,??DataTable11_5  ;; 0x400b1030
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000046   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004A   0x....             LDR.N    R1,??DataTable11_5  ;; 0x400b1030
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE000             B.N      ??Pic_save_5
    310            }
    311            return RES_OK;
   \                     ??Pic_save_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??Pic_save_5: (+1)
   \   00000054   0xBC10             POP      {R4}
   \   00000056   0x4770             BX       LR               ;; return
    312          }
    313          
    314          

   \                                 In section .text, align 2, keep-with-next
    315          DRESULT Pic_save_end()
    316          {
   \                     Pic_save_end: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    317            ESDHC_COMMAND_STRUCT command;
    318             do
    319              {
    320                
    321                command.COMMAND  = ESDHC_CMD12;
   \                     ??Pic_save_end_0: (+1)
   \   00000004   0x200C             MOVS     R0,#+12
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    322                command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    323                command.ARGUMENT = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9001             STR      R0,[SP, #+4]
    324                command.READ     = FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0008      STRB     R0,[SP, #+8]
    325                command.BLOCKS   = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
    326                if(ESDHC_OK==SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command));//uartPrintf("CND12发送成功\n");
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x.... 0x....      BL       SDHC_ioctl
   \   00000026   0x0004             MOVS     R4,R0
    327          #if PRINT
    328                uartPrintf("等待......\n");
    329          #endif
    330                command.COMMAND  = ESDHC_CMD13;   //获取卡当前的状态
   \   00000028   0x200D             MOVS     R0,#+13
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    331                command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF88D 0x0001      STRB     R0,[SP, #+1]
    332                command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000034   0x....             LDR.N    R0,??DataTable11_2
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6940             LDR      R0,[R0, #+20]
   \   0000003A   0x9001             STR      R0,[SP, #+4]
    333                command.READ     = FALSE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    334                command.BLOCKS   = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9003             STR      R0,[SP, #+12]
    335                if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x.... 0x....      BL       SDHC_ioctl
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??Pic_save_end_1
    336                {
    337          #if PRINT
    338                uartPrintf("错误返回2\n");
    339          #endif  
    340                return RES_ERROR;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE013             B.N      ??Pic_save_end_2
    341                }
    342                if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??Pic_save_end_1: (+1)
   \   00000056   0x9804             LDR      R0,[SP, #+16]
   \   00000058   0x....             LDR.N    R1,??DataTable11_6  ;; 0xffd98008
   \   0000005A   0x4208             TST      R0,R1
   \   0000005C   0xD001             BEQ.N    ??Pic_save_end_3
    343                {
    344          #if PRINT
    345                uartPrintf("错误返回3\n");
    346          #endif
    347                return RES_ERROR; 
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE00D             B.N      ??Pic_save_end_2
    348                }
    349              }
    350             while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));    
   \                     ??Pic_save_end_3: (+1)
   \   00000062   0x9804             LDR      R0,[SP, #+16]
   \   00000064   0xF410 0x50F8      ANDS     R0,R0,#0x1F00
   \   00000068   0xF5B0 0x6F10      CMP      R0,#+2304
   \   0000006C   0xD1CA             BNE.N    ??Pic_save_end_0
    351              
    352          #if PRINT
    353              uartPrintf("等待完成\n");
    354          #endif
    355          
    356              return count ? RES_ERROR : RES_OK;
   \   0000006E   0x....             LDR.N    R0,??DataTable11_7
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD001             BEQ.N    ??Pic_save_end_4
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE000             B.N      ??Pic_save_end_5
   \                     ??Pic_save_end_4: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??Pic_save_end_5: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??Pic_save_end_2: (+1)
   \   0000007E   0xB008             ADD      SP,SP,#+32
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
    357          }
    358          
    359              
    360              
    361              
    362              
    363              
    364          
    365            
    366          
    367          
    368          
    369          
    370          
    371          
    372          
    373          
    374          
    375          
    376          
    377          
    378          
    379          
    380          
    381          
    382          
    383          
    384          
    385          
    386          
    387          
    388          
    389          
    390          
    391          
    392          
    393          
    394          
    395          
    396          
    397          
    398          
    399          
    400          
    401          
    402          

   \                                 In section .text, align 2, keep-with-next
    403          DRESULT disk_write(u8 drv,const u8 *buff,u32 sector,u32  count)
    404          {
   \                     disk_write: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001D             MOVS     R5,R3
    405            
    406              ESDHC_COMMAND_STRUCT command;
    407              SDCARD_STRUCT_PTR    sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   0000000A   0x....             LDR.N    R4,??DataTable11_1
    408          
    409              //检查参数
    410              if (drv || !count) return RES_PARERR;
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??disk_write_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??disk_write_1
   \                     ??disk_write_0: (+1)
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE09C             B.N      ??disk_write_2
    411              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_write_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable11
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD501             BPL.N    ??disk_write_3
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE096             B.N      ??disk_write_2
    412              if (Stat & STA_PROTECT) return RES_WRPRT;
   \                     ??disk_write_3: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable11
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x0740             LSLS     R0,R0,#+29
   \   0000002C   0xD501             BPL.N    ??disk_write_4
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE090             B.N      ??disk_write_2
    413             
    414          
    415              //检测缓存区是否为空
    416              if ((NULL == buff)) return RES_ERROR;
   \                     ??disk_write_4: (+1)
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD101             BNE.N    ??disk_write_5
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE08C             B.N      ??disk_write_2
    417          
    418          
    419              if (!sdcard_ptr->SDHC)
   \                     ??disk_write_5: (+1)
   \   0000003A   0x7C20             LDRB     R0,[R4, #+16]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD100             BNE.N    ??disk_write_6
    420                  //sector *= 512;	//扇区号转化为起始地址
    421                  sector = sector << IO_SDCARD_BLOCK_SIZE_POWER; 
   \   00000040   0x027F             LSLS     R7,R7,#+9
    422          
    423             
    424              if(1)
    425              {
    426               command.COMMAND  = ESDHC_ACMD23;
   \                     ??disk_write_6: (+1)
   \   00000042   0x2057             MOVS     R0,#+87
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
    427                command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    428                command.ARGUMENT = sector;
   \   0000004E   0x9701             STR      R7,[SP, #+4]
    429                command.READ     = FALSE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF88D 0x0008      STRB     R0,[SP, #+8]
    430                command.BLOCKS   = count;
   \   00000056   0x9503             STR      R5,[SP, #+12]
    431                 if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x.... 0x....      BL       SDHC_ioctl
    432                  {
    433                    
    434          #if PRINT
    435                    uartPrintf("多扇区写入时扇区擦除成功\n");
    436          
    437          #endif
    438                     
    439                  }
    440              }
    441              
    442               
    443              if (count == 1) //写单个扇区
   \   00000060   0x2D01             CMP      R5,#+1
   \   00000062   0xD119             BNE.N    ??disk_write_7
    444              {
    445                  command.COMMAND  = ESDHC_CMD24;
   \   00000064   0x2018             MOVS     R0,#+24
   \   00000066   0xF88D 0x0000      STRB     R0,[SP, #+0]
    446                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    447                  command.ARGUMENT = sector;
   \   00000070   0x9701             STR      R7,[SP, #+4]
    448                  command.READ     = FALSE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF88D 0x0008      STRB     R0,[SP, #+8]
    449                  command.BLOCKS   = count;
   \   00000078   0x9503             STR      R5,[SP, #+12]
    450          
    451                  if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   0000007A   0xA900             ADD      R1,SP,#+0
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x.... 0x....      BL       SDHC_ioctl
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD12D             BNE.N    ??disk_write_8
    452                  {
    453                      //if (hw_sdhc_send_block(buff,512))
    454                      if (SDHC_send_block(buff, IO_SDCARD_BLOCK_SIZE))
   \   00000086   0xF44F 0x7100      MOV      R1,#+512
   \   0000008A   0x0030             MOVS     R0,R6
   \   0000008C   0x.... 0x....      BL       SDHC_send_block
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD026             BEQ.N    ??disk_write_8
    455                          count = 0;
   \   00000094   0x2500             MOVS     R5,#+0
   \   00000096   0xE024             B.N      ??disk_write_8
    456                  }
    457              }
    458              else //写多个扇区
    459              {
    460                 
    461                  command.COMMAND  = ESDHC_CMD25;
   \                     ??disk_write_7: (+1)
   \   00000098   0x2019             MOVS     R0,#+25
   \   0000009A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    462                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF88D 0x0001      STRB     R0,[SP, #+1]
    463                  command.ARGUMENT = sector;
   \   000000A4   0x9701             STR      R7,[SP, #+4]
    464                  command.READ     = FALSE;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF88D 0x0008      STRB     R0,[SP, #+8]
    465                  command.BLOCKS   = count;
   \   000000AC   0x9503             STR      R5,[SP, #+12]
    466                  
    467          
    468                  if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000AE   0xA900             ADD      R1,SP,#+0
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0x.... 0x....      BL       SDHC_ioctl
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD113             BNE.N    ??disk_write_8
    469                  {
    470          #if PRINT
    471                    uartPrintf("CMD25发送完毕\n");
    472          #endif
    473                     // 
    474                    gpio_set(PORTB,22,1);
   \   000000BA   0x2201             MOVS     R2,#+1
   \   000000BC   0x2116             MOVS     R1,#+22
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      BL       gpio_set
    475                      if (SDHC_send_block(buff,IO_SDCARD_BLOCK_SIZE*count))
   \   000000C4   0xF44F 0x7000      MOV      R0,#+512
   \   000000C8   0xFB00 0xF105      MUL      R1,R0,R5
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0x.... 0x....      BL       SDHC_send_block
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD000             BEQ.N    ??disk_write_9
    476                      {
    477                        count = 0;
   \   000000D6   0x2500             MOVS     R5,#+0
    478          #if PRINT
    479                        uartPrintf("多块扇区写入完毕\n");
    480          #endif
    481                       
    482                      }
    483                    gpio_set(PORTB,22,0);
   \                     ??disk_write_9: (+1)
   \   000000D8   0x2200             MOVS     R2,#+0
   \   000000DA   0x2116             MOVS     R1,#+22
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0x.... 0x....      BL       gpio_set
    484                  }
    485              }
    486          
    487              //等待完成
    488            do
    489              {
    490                
    491                command.COMMAND  = ESDHC_CMD12;
   \                     ??disk_write_8: (+1)
   \   000000E2   0x200C             MOVS     R0,#+12
   \   000000E4   0xF88D 0x0000      STRB     R0,[SP, #+0]
    492                command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF88D 0x0001      STRB     R0,[SP, #+1]
    493                command.ARGUMENT = 0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x9001             STR      R0,[SP, #+4]
    494                command.READ     = FALSE;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF88D 0x0008      STRB     R0,[SP, #+8]
    495                command.BLOCKS   = 0;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x9003             STR      R0,[SP, #+12]
    496                if(ESDHC_OK==SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command));//uartPrintf("CND12发送成功\n");
   \   000000FC   0xA900             ADD      R1,SP,#+0
   \   000000FE   0x2002             MOVS     R0,#+2
   \   00000100   0x.... 0x....      BL       SDHC_ioctl
   \   00000104   0x0006             MOVS     R6,R0
    497                     
    498              
    499              
    500                 // command.COMMAND  = ESDHC_CMD12;     //发送强制多块扇区读入的命令
    501                  //command.TYPE     = ESDHC_TYPE_NORMAL;
    502                //  command.ARGUMENT = sdcard_ptr->ADDRESS;
    503                //  command.READ     = FALSE;
    504                //  command.BLOCKS   = 0;
    505                //  SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command);
    506          #if PRINT
    507                uartPrintf("等待......\n");
    508          #endif
    509                 
    510          
    511              
    512                  command.COMMAND  = ESDHC_CMD13;   //获取卡当前的状态
   \   00000106   0x200D             MOVS     R0,#+13
   \   00000108   0xF88D 0x0000      STRB     R0,[SP, #+0]
    513                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    514                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000112   0x6960             LDR      R0,[R4, #+20]
   \   00000114   0x9001             STR      R0,[SP, #+4]
    515                  command.READ     = FALSE;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF88D 0x0008      STRB     R0,[SP, #+8]
    516                  command.BLOCKS   = 0;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x9003             STR      R0,[SP, #+12]
    517              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000120   0xA900             ADD      R1,SP,#+0
   \   00000122   0x2002             MOVS     R0,#+2
   \   00000124   0x.... 0x....      BL       SDHC_ioctl
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD001             BEQ.N    ??disk_write_10
    518                  
    519              {
    520          #if PRINT
    521                uartPrintf("错误返回2\n");
    522          #endif  
    523                return RES_ERROR;
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xE011             B.N      ??disk_write_2
    524              }
    525             
    526              if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??disk_write_10: (+1)
   \   00000130   0x9804             LDR      R0,[SP, #+16]
   \   00000132   0x....             LDR.N    R1,??DataTable11_6  ;; 0xffd98008
   \   00000134   0x4208             TST      R0,R1
   \   00000136   0xD001             BEQ.N    ??disk_write_11
    527              {
    528          #if PRINT
    529                uartPrintf("错误返回3\n");
    530          #endif
    531                return RES_ERROR;
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xE00B             B.N      ??disk_write_2
    532              }
    533              
    534              
    535            
    536              
    537              //command.COMMAND  = ESDHC_CMD24;
    538              } while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));    
   \                     ??disk_write_11: (+1)
   \   0000013C   0x9804             LDR      R0,[SP, #+16]
   \   0000013E   0xF410 0x50F8      ANDS     R0,R0,#0x1F00
   \   00000142   0xF5B0 0x6F10      CMP      R0,#+2304
   \   00000146   0xD1CC             BNE.N    ??disk_write_8
    539              
    540          #if PRINT
    541              uartPrintf("等待完成\n");
    542          #endif
    543          
    544              return count ? RES_ERROR : RES_OK;
   \   00000148   0x2D00             CMP      R5,#+0
   \   0000014A   0xD001             BEQ.N    ??disk_write_12
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xE000             B.N      ??disk_write_13
   \                     ??disk_write_12: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \                     ??disk_write_13: (+1)
   \   00000152   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_write_2: (+1)
   \   00000154   0xB009             ADD      SP,SP,#+36
   \   00000156   0xBDF0             POP      {R4-R7,PC}       ;; return
    545          }
    546          
    547          
    548          //=========================================================================
    549          //函数名称：disk_ioctl                                                        
    550          //功能概要：数据盘控制                                                
    551          //参数说明：drv:设备号
    552          //         ctrl:命令
    553          //         buff:数据的缓存区首地址
    554          //函数返回：RES_OK：成功，其它：失败                                                              
    555          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    556          DRESULT disk_ioctl(u8 drv,u8 ctrl,void  *buff)
    557          {
   \                     disk_ioctl: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0014             MOVS     R4,R2
    558              DRESULT  res;
    559              ESDHC_COMMAND_STRUCT command;
    560              SDCARD_STRUCT_PTR	 sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;	
   \   00000006   0x....             LDR.N    R2,??DataTable11_1
    561              
    562              if (drv) return RES_PARERR;
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??disk_ioctl_0
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE051             B.N      ??disk_ioctl_1
    563              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_ioctl_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable11
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x07C0             LSLS     R0,R0,#+31
   \   00000018   0xD501             BPL.N    ??disk_ioctl_2
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xE04B             B.N      ??disk_ioctl_1
    564              
    565              res = RES_ERROR;
   \                     ??disk_ioctl_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
    566              switch (ctrl) 
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD008             BEQ.N    ??disk_ioctl_3
   \   00000026   0x2901             CMP      R1,#+1
   \   00000028   0xD008             BEQ.N    ??disk_ioctl_4
   \   0000002A   0x2902             CMP      R1,#+2
   \   0000002C   0xD00A             BEQ.N    ??disk_ioctl_5
   \   0000002E   0x2903             CMP      R1,#+3
   \   00000030   0xD00D             BEQ.N    ??disk_ioctl_6
   \   00000032   0x2905             CMP      R1,#+5
   \   00000034   0xD03C             BEQ.N    ??disk_ioctl_7
   \   00000036   0xE03C             B.N      ??disk_ioctl_8
    567              {
    568              case CTRL_SYNC :
    569                  res = RES_OK;
   \                     ??disk_ioctl_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
    570                  break;
   \   0000003A   0xE03B             B.N      ??disk_ioctl_9
    571              case GET_SECTOR_COUNT :
    572                  *(unsigned long*)buff = sdcard_ptr->NUM_BLOCKS;
   \                     ??disk_ioctl_4: (+1)
   \   0000003C   0x68D0             LDR      R0,[R2, #+12]
   \   0000003E   0x6020             STR      R0,[R4, #+0]
    573                  res = RES_OK;
   \   00000040   0x2000             MOVS     R0,#+0
    574                  break; 
   \   00000042   0xE037             B.N      ??disk_ioctl_9
    575              case GET_SECTOR_SIZE :
    576                  *(unsigned short*)buff = IO_SDCARD_BLOCK_SIZE;
   \                     ??disk_ioctl_5: (+1)
   \   00000044   0xF44F 0x7000      MOV      R0,#+512
   \   00000048   0x8020             STRH     R0,[R4, #+0]
    577                  res = RES_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
    578                  break;
   \   0000004C   0xE032             B.N      ??disk_ioctl_9
    579              case GET_BLOCK_SIZE :
    580                  command.COMMAND  = ESDHC_CMD9;
   \                     ??disk_ioctl_6: (+1)
   \   0000004E   0x2009             MOVS     R0,#+9
   \   00000050   0xF88D 0x0000      STRB     R0,[SP, #+0]
    581                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF88D 0x0001      STRB     R0,[SP, #+1]
    582                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   0000005A   0x6950             LDR      R0,[R2, #+20]
   \   0000005C   0x9001             STR      R0,[SP, #+4]
    583                  command.READ     = FALSE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF88D 0x0008      STRB     R0,[SP, #+8]
    584                  command.BLOCKS   = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x9003             STR      R0,[SP, #+12]
    585                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000068   0xA900             ADD      R1,SP,#+0
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       SDHC_ioctl
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??disk_ioctl_10
    586                      return RES_ERROR;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE01E             B.N      ??disk_ioctl_1
    587          
    588                  if (0 == (command.RESPONSE[3] & 0x00C00000)) //SD V1
   \                     ??disk_ioctl_10: (+1)
   \   00000078   0x9807             LDR      R0,[SP, #+28]
   \   0000007A   0xF410 0x0F40      TST      R0,#0xC00000
   \   0000007E   0xD10B             BNE.N    ??disk_ioctl_11
    589                      *(unsigned long*)buff = ((((command.RESPONSE[2] >> 18) & 0x7F) + 1) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));
   \   00000080   0x9806             LDR      R0,[SP, #+24]
   \   00000082   0xF3C0 0x4086      UBFX     R0,R0,#+18,#+7
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x9907             LDR      R1,[SP, #+28]
   \   0000008A   0x0A09             LSRS     R1,R1,#+8
   \   0000008C   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   00000090   0x1E49             SUBS     R1,R1,#+1
   \   00000092   0x4088             LSLS     R0,R0,R1
   \   00000094   0x6020             STR      R0,[R4, #+0]
   \   00000096   0xE009             B.N      ??disk_ioctl_12
    590                  else //SD V2
    591                      *(unsigned long*)buff = (((command.RESPONSE[2] >> 18) & 0x7F) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));				
   \                     ??disk_ioctl_11: (+1)
   \   00000098   0x9806             LDR      R0,[SP, #+24]
   \   0000009A   0xF3C0 0x4086      UBFX     R0,R0,#+18,#+7
   \   0000009E   0x9907             LDR      R1,[SP, #+28]
   \   000000A0   0x0A09             LSRS     R1,R1,#+8
   \   000000A2   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   000000A6   0x1E49             SUBS     R1,R1,#+1
   \   000000A8   0x4088             LSLS     R0,R0,R1
   \   000000AA   0x6020             STR      R0,[R4, #+0]
    592                  res = RES_OK;
   \                     ??disk_ioctl_12: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
    593                  break;
   \   000000AE   0xE001             B.N      ??disk_ioctl_9
    594              case CTRL_DISK_TYPE:
    595                  res = sdcard_ptr->CARD_TYPE;
   \                     ??disk_ioctl_7: (+1)
   \   000000B0   0x7810             LDRB     R0,[R2, #+0]
    596              default:
    597                  res = RES_PARERR;
   \                     ??disk_ioctl_8: (+1)
   \   000000B2   0x2004             MOVS     R0,#+4
    598              }
    599              
    600              return res;
   \                     ??disk_ioctl_9: (+1)
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_ioctl_1: (+1)
   \   000000B6   0xB008             ADD      SP,SP,#+32
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    601          }
    602          
    603          //=========================================================================
    604          //函数名称：disk_status                                                        
    605          //功能概要：返回数据盘状态                                              
    606          //参数说明：drv：数据盘号
    607          //函数返回：状态                                                        
    608          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    609          u8 disk_status (u8 drv)
    610          {
    611              if (drv) return STA_NOINIT;
   \                     disk_status: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ.N    ??disk_status_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE001             B.N      ??disk_status_1
    612              return Stat;
   \                     ??disk_status_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable11
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \                     ??disk_status_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    613          }
    614          
    615          //=========================================================================
    616          //函数名称：disk_timerproc                                                        
    617          //功能概要：检测SD卡状态                                              
    618          //参数说明：无
    619          //函数返回：无                                                        
    620          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    621          void disk_timerproc (void)
    622          {
    623              u8 s;   
    624              
    625              Timer++;
   \                     disk_timerproc: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_8
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable11_8
   \   00000008   0x6008             STR      R0,[R1, #+0]
    626              s = Stat;
   \   0000000A   0x....             LDR.N    R0,??DataTable11
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
    627              
    628              if (SDCARD_GPIO_PROTECT == 0)       
   \   0000000E   0x....             LDR.N    R1,??DataTable11_9  ;; 0x400ff110
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x0109             LSLS     R1,R1,#+4
   \   00000014   0xD402             BMI.N    ??disk_timerproc_0
    629              {
    630                  s &= ~STA_PROTECT;             //写使能
   \   00000016   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   0000001A   0xE001             B.N      ??disk_timerproc_1
    631              }
    632              else            
    633              {
    634                  s |= STA_PROTECT;               //写保护
   \                     ??disk_timerproc_0: (+1)
   \   0000001C   0xF050 0x0004      ORRS     R0,R0,#0x4
    635              }
    636              if (SDCARD_GPIO_DETECT == 0)        //卡插入
   \                     ??disk_timerproc_1: (+1)
   \   00000020   0x....             LDR.N    R1,??DataTable11_9  ;; 0x400ff110
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x00C9             LSLS     R1,R1,#+3
   \   00000026   0xD402             BMI.N    ??disk_timerproc_2
    637                  s &= ~STA_NODISK;
   \   00000028   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   0000002C   0xE001             B.N      ??disk_timerproc_3
    638              else                                //卡不存在
    639                  s |= (STA_NODISK | STA_NOINIT);
   \                     ??disk_timerproc_2: (+1)
   \   0000002E   0xF050 0x0003      ORRS     R0,R0,#0x3
    640              
    641              Stat = s;                           //更新卡状态
   \                     ??disk_timerproc_3: (+1)
   \   00000032   0x....             LDR.N    R1,??DataTable11
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    642          }
   \   00000036   0x4770             BX       LR               ;; return
    643          
    644          //=========================================================================
    645          //函数名称：SD_init                                                        
    646          //功能概要：检测SD卡状态                                              
    647          //参数说明：无
    648          //函数返回：无                                                        
    649          //=========================================================================
    650          
    651          

   \                                 In section .text, align 4, keep-with-next
    652          void SD_init()
    653          {
   \                     SD_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    654            DisableInterrupts;  
   \   00000002   0xB672             CPSID i
    655            SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
    656                                | SIM_SCGC5_PORTB_MASK
    657                                | SIM_SCGC5_PORTC_MASK
    658                                | SIM_SCGC5_PORTD_MASK
    659                                | SIM_SCGC5_PORTE_MASK );
   \   00000004   0x....             LDR.N    R0,??DataTable11_10  ;; 0x40048038
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF450 0x5078      ORRS     R0,R0,#0x3E00
   \   0000000C   0x....             LDR.N    R1,??DataTable11_10  ;; 0x40048038
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    660            PLL_Init();
   \   00000010   0x.... 0x....      BL       PLL_Init
    661            disk_initialize(0); 
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       disk_initialize
    662            EnableInterrupts;
   \   0000001A   0xB662             CPSIE i
    663          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     SDHC_Card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     sdcard_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x400B1020         DC32     0x400b1020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0xFFD98008         DC32     0xffd98008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x400FF110         DC32     0x400ff110

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x40048038         DC32     0x40048038

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GetCardStat
       4   Pic_save
      40   Pic_save_end
        40   -> SDHC_ioctl
      48   Pic_save_init
        48   -> SDHC_ioctl
       8   SD_init
         8   -> PLL_Init
         8   -> disk_initialize
       0   SetCardStat
      48   disk_initialize
        48   -> SDHC_ioctl
      40   disk_ioctl
        40   -> SDHC_ioctl
      48   disk_read
        48   -> SDHC_ioctl
        48   -> SDHC_receive_block
       0   disk_status
       0   disk_timerproc
      56   disk_write
        56   -> SDHC_ioctl
        56   -> SDHC_send_block
        56   -> gpio_set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       8  GetCardStat
      88  Pic_save
     130  Pic_save_end
     158  Pic_save_init
      24  SDHC_Card
      30  SD_init
       8  SetCardStat
       1  Stat
       4  Timer
     568  disk_initialize
     186  disk_ioctl
     182  disk_read
      16  disk_status
      56  disk_timerproc
     344  disk_write
       4  sdcard_ptr

 
    32 bytes in section .bss
     1 byte  in section .data
 1 818 bytes in section .text
 
 1 818 bytes of CODE memory
    33 bytes of DATA memory

Errors: none
Warnings: 2

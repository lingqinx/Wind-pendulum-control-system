###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      15/Aug/2015  12:46:26 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\i #
#                    2c\i2c.c                                                 #
#    Command line =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\i #
#                    2c\i2c.c -lCN C:\Users\Administrator\Desktop\MPU60508.12 #
#                    \build\gpio_demo\FLASH\List\ -lB                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\ -o C:\Users\Administrator\Desktop\MPU6050 #
#                    8.12\build\gpio_demo\FLASH\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\IAR Systems\Embedded     #
#                    Workbench 6.5\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\ -I C:\Users\Administrator\Desktop\MPU60508.12\bui #
#                    ld\gpio_demo\..\..\src\common\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\cpu\ -I C:\Users\Administrator\Desktop\MPU6 #
#                    0508.12\build\gpio_demo\..\..\src\drivers\ -I            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\gpio\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\olcd\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\diskio\ -I                          #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\iospi\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\wdog\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\mcg\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\uart\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\lptmr\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\LED\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\fun\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\FTM\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\pit\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\DIPswitch\ -I                       #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\motor\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\laser\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\i2c\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\ADdevice\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\adc\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\serial_digtal_scope\ -I             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MMA845x\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\exti\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\dma\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\platforms\ -I C:\Users\Administrator\Deskto #
#                    p\MPU60508.12\build\gpio_demo\..\..\src\projects\ -I     #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\projects\gpio_demo\ -I                      #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MPU6050\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -Ol                          #
#    List file    =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\i2c.lst                                    #
#    Object file  =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\Obj\i2c.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\i2c\i2c.c
      1          #include "common.h"
      2          #include "i2c.h"
      3          

   \                                 In section .data, align 4
      4          volatile struct I2C_MemMap *I2Cx[2] = {I2C0_BASE_PTR, I2C1_BASE_PTR}; //定义两个指针数组保存 I2Cx 的地址
   \                     I2Cx:
   \   00000000   0x40066000         DC32 40066000H, 40067000H
   \              0x40067000   
      5          void i2c_pause(void);
      6          //I2C0_C1 |= ( I2C_C1_TX_MASK);
      7          
      8          /*
      9           * i2c_init
     10           * I2C通用初始化函数
     11           * 
     12           * 参数:
     13           *    IICx--选择I2C模块的通道
     14           *      |__0 I2C0
     15           *      |__1 I2C1
     16           *    scl_frq=0,则根据mult（I2C_F_MULT）和scl_dev（I2C_F_ICR）计算,
     17           *      |       选值请参考K60Pin144 Sub-Family Reference Manual P1468
     18           *      |       Table 50-41. I2C Divider and Hold Values
     19           *      |       scl_frq<>0,则根据下表选频率
     20           *      |__0--根据mult和scl_dev计算
     21           *      |__1--50khz=(50Mhz/1*1024=48.828125KHz)
     22           *      |__2--100khz=(50Mhz/1*512=97.65625KHz)
     23           *      |__3--150khz=(50Mhz/1*320=156.25KHz)
     24           *      |__4--200khz=(50Mhz/1*256=195.3215KHz)
     25           *      |__5--250khz=(50Mhz/1*192=260.4167KHz)
     26           *      |__6--300khz=(50Mhz/1*160=312.5KHz)
     27           *      |__7--400khz=(50Mhz/1*128=390.625KHz)
     28           * 输出:
     29           *    0--配置错误
     30           *    1--配置成功
     31           */

   \                                 In section .text, align 2, keep-with-next
     32          uint8 i2c_init(I2Cn i2cn,uint8 mult,uint8 scl_dev,uint8 scl_frq)
     33          {
   \                     i2c_init: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     34            uint8 PS;
     35            if(scl_frq==0)
   \   00000002   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD003             BEQ.N    ??i2c_init_0
     36            {}
     37              else if(scl_frq==1)
   \   00000008   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD11E             BNE.N    ??i2c_init_1
     38              {
     39                PS=0x33;
   \   0000000E   0x2433             MOVS     R4,#+51
     40              }
     41              else if(scl_frq==2)
     42              {
     43                PS=0x2B;
     44              }
     45              else if(scl_frq==3)
     46              {
     47                PS=0x28;
     48              }
     49              else if(scl_frq==4)
     50              {
     51                PS=0x23;
     52              }
     53              else if(scl_frq==5)
     54              {
     55                PS=0x21;
     56              }
     57              else if(scl_frq==6)
     58              {
     59                PS=0x20;
     60              }
     61              else if(scl_frq==7)
     62              {
     63                PS=0x17;
     64              }
     65            else  return 0;
     66          
     67              if(i2cn == I2C0)
   \                     ??i2c_init_0: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD146             BNE.N    ??i2c_init_2
     68              {
     69                  /* 开启时钟 */
     70                  SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;         //开启 I2C0时钟
   \   00000016   0x....             LDR.N    R5,??DataTable3  ;; 0x40048034
   \   00000018   0x682D             LDR      R5,[R5, #+0]
   \   0000001A   0xF055 0x0540      ORRS     R5,R5,#0x40
   \   0000001E   0x....             LDR.N    R6,??DataTable3  ;; 0x40048034
   \   00000020   0x6035             STR      R5,[R6, #+0]
     71          
     72                  /* 配置 I2C0功能的 GPIO 接口 */
     73                  if(I2C0_SCL == PTB0)
     74                      PORTB_PCR0 = PORT_PCR_MUX(2);
   \   00000022   0x....             LDR.N    R5,??DataTable3_1  ;; 0x4004a000
   \   00000024   0xF44F 0x7600      MOV      R6,#+512
   \   00000028   0x602E             STR      R6,[R5, #+0]
     75                  else if(I2C0_SCL == PTB2)
     76                      PORTB_PCR2 = PORT_PCR_MUX(2);
     77                  else if(I2C0_SCL == PTD8)
     78                      PORTD_PCR8 = PORT_PCR_MUX(2);
     79                  else
     80                  {
     81                      assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
     82                      return 0;
     83                  }
     84          
     85                  if(I2C0_SDA == PTB1)
     86                      PORTB_PCR1 = PORT_PCR_MUX(2);
   \   0000002A   0x....             LDR.N    R5,??DataTable3_2  ;; 0x4004a004
   \   0000002C   0xF44F 0x7600      MOV      R6,#+512
   \   00000030   0x602E             STR      R6,[R5, #+0]
     87                  else if(I2C0_SDA == PTB3)
     88                      PORTB_PCR3 = PORT_PCR_MUX(2);
     89                  else if(I2C0_SDA == PTD9)
     90                      PORTD_PCR9 = PORT_PCR_MUX(2);
     91                  else
     92                  {
     93                      assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
     94                      return 0;
     95                  }
     96                  //设置I2C波特率
     97                  if(scl_frq==0)
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD129             BNE.N    ??i2c_init_3
     98                      I2C_F_REG(I2Cx[i2cn])  = I2C_F_MULT(mult) | I2C_F_ICR(scl_dev) ;  // I2C Frequency Divider register (I2Cx_F)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x....             LDR.N    R3,??DataTable3_3
   \   0000003C   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   00000040   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000044   0xEA52 0x1181      ORRS     R1,R2,R1, LSL #+6
   \   00000048   0x7041             STRB     R1,[R0, #+1]
   \   0000004A   0xE026             B.N      ??i2c_init_4
   \                     ??i2c_init_1: (+1)
   \   0000004C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004E   0x2B02             CMP      R3,#+2
   \   00000050   0xD101             BNE.N    ??i2c_init_5
   \   00000052   0x242B             MOVS     R4,#+43
   \   00000054   0xE7DC             B.N      ??i2c_init_0
   \                     ??i2c_init_5: (+1)
   \   00000056   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000058   0x2B03             CMP      R3,#+3
   \   0000005A   0xD101             BNE.N    ??i2c_init_6
   \   0000005C   0x2428             MOVS     R4,#+40
   \   0000005E   0xE7D7             B.N      ??i2c_init_0
   \                     ??i2c_init_6: (+1)
   \   00000060   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000062   0x2B04             CMP      R3,#+4
   \   00000064   0xD101             BNE.N    ??i2c_init_7
   \   00000066   0x2423             MOVS     R4,#+35
   \   00000068   0xE7D2             B.N      ??i2c_init_0
   \                     ??i2c_init_7: (+1)
   \   0000006A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000006C   0x2B05             CMP      R3,#+5
   \   0000006E   0xD101             BNE.N    ??i2c_init_8
   \   00000070   0x2421             MOVS     R4,#+33
   \   00000072   0xE7CD             B.N      ??i2c_init_0
   \                     ??i2c_init_8: (+1)
   \   00000074   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000076   0x2B06             CMP      R3,#+6
   \   00000078   0xD101             BNE.N    ??i2c_init_9
   \   0000007A   0x2420             MOVS     R4,#+32
   \   0000007C   0xE7C8             B.N      ??i2c_init_0
   \                     ??i2c_init_9: (+1)
   \   0000007E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000080   0x2B07             CMP      R3,#+7
   \   00000082   0xD101             BNE.N    ??i2c_init_10
   \   00000084   0x2417             MOVS     R4,#+23
   \   00000086   0xE7C3             B.N      ??i2c_init_0
   \                     ??i2c_init_10: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE031             B.N      ??i2c_init_11
     99                  else
    100                      I2C_F_REG(I2Cx[i2cn])  = I2C_F_MULT(0x00) | I2C_F_ICR(PS) ;  // I2C Frequency Divider register (I2Cx_F)
   \                     ??i2c_init_3: (+1)
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x....             LDR.N    R1,??DataTable3_3
   \   00000090   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000094   0xF014 0x013F      ANDS     R1,R4,#0x3F
   \   00000098   0x7041             STRB     R1,[R0, #+1]
    101                  
    102                  //使能I2C0，不发送应答信号
    103          	I2C0_C1 = I2C_C1_IICEN_MASK | I2C_C1_TXAK_MASK;
   \                     ??i2c_init_4: (+1)
   \   0000009A   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40066002
   \   0000009C   0x2188             MOVS     R1,#+136
   \   0000009E   0x7001             STRB     R1,[R0, #+0]
    104                  //I2C_C1_REG(I2Cx[i2cn]) = I2C_C1_IICEN_MASK;
    105              return 1;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE025             B.N      ??i2c_init_11
    106              }
    107              else
    108              {
    109                  /* 开启时钟 */
    110                  SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK;         //开启 I2C1时钟
   \                     ??i2c_init_2: (+1)
   \   000000A4   0x....             LDR.N    R5,??DataTable3  ;; 0x40048034
   \   000000A6   0x682D             LDR      R5,[R5, #+0]
   \   000000A8   0xF055 0x0580      ORRS     R5,R5,#0x80
   \   000000AC   0x....             LDR.N    R6,??DataTable3  ;; 0x40048034
   \   000000AE   0x6035             STR      R5,[R6, #+0]
    111          
    112                  /* 配置 I2C1功能的 GPIO 接口 */
    113                  if(I2C1_SCL == PTE1)
    114                      PORTE_PCR1 = PORT_PCR_MUX(6);
    115                  else if(I2C1_SCL == PTC10)
    116                      PORTC_PCR10 = PORT_PCR_MUX(2);
   \   000000B0   0x....             LDR.N    R5,??DataTable3_5  ;; 0x4004b028
   \   000000B2   0xF44F 0x7600      MOV      R6,#+512
   \   000000B6   0x602E             STR      R6,[R5, #+0]
    117                  else
    118                  {
    119                      assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
    120                      return 0;
    121                  }
    122          
    123                  if(I2C1_SDA == PTE0)
    124                      PORTE_PCR0 = PORT_PCR_MUX(6);
    125                  else if (I2C1_SDA == PTC11)
    126                      PORTC_PCR11 = PORT_PCR_MUX(2);
   \   000000B8   0x....             LDR.N    R5,??DataTable3_6  ;; 0x4004b02c
   \   000000BA   0xF44F 0x7600      MOV      R6,#+512
   \   000000BE   0x602E             STR      R6,[R5, #+0]
    127                  else
    128                  {
    129                      assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
    130                      return 0;
    131                  }
    132                  //设置I2C波特率
    133                  if(scl_frq==0)
   \   000000C0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000C2   0x2B00             CMP      R3,#+0
   \   000000C4   0xD109             BNE.N    ??i2c_init_12
    134                      I2C_F_REG(I2Cx[i2cn])  = I2C_F_MULT(mult) | I2C_F_ICR(scl_dev) ;  // I2C Frequency Divider register (I2Cx_F)
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x....             LDR.N    R3,??DataTable3_3
   \   000000CA   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   000000CE   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   000000D2   0xEA52 0x1181      ORRS     R1,R2,R1, LSL #+6
   \   000000D6   0x7041             STRB     R1,[R0, #+1]
   \   000000D8   0xE006             B.N      ??i2c_init_13
    135                  else
    136                      I2C_F_REG(I2Cx[i2cn])  = I2C_F_MULT(0x00) | I2C_F_ICR(PS) ;  // I2C Frequency Divider register (I2Cx_F)
   \                     ??i2c_init_12: (+1)
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0x....             LDR.N    R1,??DataTable3_3
   \   000000DE   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   000000E2   0xF014 0x013F      ANDS     R1,R4,#0x3F
   \   000000E6   0x7041             STRB     R1,[R0, #+1]
    137                  
    138                  //使能I2C1，不发送应答信号
    139          	I2C1_C1 = I2C_C1_IICEN_MASK | I2C_C1_TXAK_MASK;
   \                     ??i2c_init_13: (+1)
   \   000000E8   0x....             LDR.N    R0,??DataTable3_7  ;; 0x40067002
   \   000000EA   0x2188             MOVS     R1,#+136
   \   000000EC   0x7001             STRB     R1,[R0, #+0]
    140                  //I2C_C1_REG(I2Cx[i2cn]) = I2C_C1_IICEN_MASK;
    141                  
    142              return 1;
   \   000000EE   0x2001             MOVS     R0,#+1
   \                     ??i2c_init_11: (+1)
   \   000000F0   0xBC70             POP      {R4-R6}
   \   000000F2   0x4770             BX       LR               ;; return
    143              }
    144              //I2C_F_REG(I2Cx)  = I2C_F_MULT(mult) | I2C_F_ICR(17) ;  // I2C Frequency Divider register (I2Cx_F)
    145              //I2C分频寄存器   I2C最大波特率为 400k
    146              // MULT=00  即  mul = 1
    147              // ICR    SCL Divider   SDA Hold Value    SCL Hold (Start) Value    SCL Hold (Stop) Value
    148              //  17       128              21                   58                         65
    149              // I2C baud rate = bus speed (Hz)/(mul × SCL divider)  即这里 50MHz/(1 ×128)=390.625kHz
    150              // SDA hold time = bus period (s) × mul × SDA hold value
    151              // SCL start hold time = bus period (s) × mul × SCL start hold value
    152              // SCL stop hold time = bus period (s) × mul × SCL stop hold value
    153          }
    154          /*
    155          //============================================================================
    156          //函数名称：hw_wait                                                        
    157          //功能概要： 在时限内,循环检测接收应答标志位,或传送完成标志位,判断MCU         
    158          //          是否接收到应答信号或一个字节是否已在总线上传送完毕                                            
    159          //参数说明：         MoudleNum:模块号       
    160          //             x:x = 1(Ack),等待应答;x = 0(Transmission),等待一个字节        
    161          //                 数据传输完成                   
    162          //函数返回：0:收到应答信号或一个字节传送完毕;
    163          //         1:未收到应答信号或一个 字节没传送完                                                                                                                            
    164          //============================================================================
    165          
    166          uint8 i2c_waitmode(I2Cn i2cn,uint8 isack)
    167          {
    168            uint16 ErrTime, i;
    169            ErrTime = 255*10;            //定义查询超时时限
    170              
    171            for (i = 0;i < ErrTime;i++)
    172            {
    173              if (isack == 1)           //等待应答信号
    174              {
    175                if(( I2C_S_REG(I2Cx[i2cn])  & I2C_S_RXAK_MASK)==0)
    176                return 0;      //传送完一个字节后,收到了从机的应答信号               
    177              }
    178              else if (isack == 0)      //等待传送完成一个字节信号
    179              {
    180                if ((I2C_S_REG(I2Cx[i2cn]) & I2C_S_IICIF_MASK) != 0)    
    181                {
    182                  (I2C_S_REG(I2Cx[i2cn]) |=(0 | I2C_S_IICIF_MASK));  //清IICIF标志位
    183                  return 0;       //成功发送完一个字节
    184                }
    185               else return 1;//配置参数出错
    186              }
    187            }
    188            if (i >= ErrTime) 
    189            {
    190              return 1;               //超时,没有收到应答信号或发送完一个字节
    191            }
    192            return 1;//???????????????????
    193          }
    194          */
    195          /*
    196          uint8 hw_iic_read1(I2Cn i2cn,uint8 DeviceAddr, uint8 AccessAddr, uint8 *Data)
    197          {      
    198            I2C_C1_REG(I2Cx[I2Cn])     |= 0x10;           //TX = 1,MCU设置为发送模式
    199            i2c_start(I2Cn);               //发送开始信号 
    200            I2C_D_REG(I2Cx[I2Cn])  = DeviceAddr & 0xfe;   //发送设备地址,并通知从机接收数据
    201            if (hw_wait('T',MoudleNum))                  //等待一个字节数据传送完成  
    202            {      
    203              return 1;                         //没有传送成功,读一个字节失败   
    204            }
    205            i2c_waitmode(i2cn,0);
    206            if (hw_wait('A',MoudleNum))                 //等待从机应答信号 
    207            {
    208              return 1;                         //没有等到应答信号,读一个字节失败 
    209            }
    210            I2C_D_REG(I2Cx[I2Cn])  = AccessAddr;        //发送访问地址    
    211            if (hw_wait('T',MoudleNum))                //等待一个字节数据传送完成 
    212            {
    213              return 1;                        //没有传送成功,读一个字节失败
    214            }
    215            if (hw_wait('A',MoudleNum))                //等待从机应答信号   
    216            {
    217              return 1;                        //没有等到应答信号,读一个字节失败  
    218            }
    219            I2C_C1_REG(I2Cx[I2Cn]) |= 0x04;//当MCU在主机模 式下，向该位写1将产生一个重新开始信号  
    220            I2C_D_REG(I2Cx[I2Cn]) = DeviceAddr | 0x01; //通知从机改为发送数据    
    221            if (hw_wait('T',MoudleNum))               //等待一个字节数据传送完成  
    222            {
    223              return 1;                       //没有传送成功,读一个字节失败 
    224            }
    225            if (hw_wait('A',MoudleNum))               //等待从机应答信号  
    226            {
    227              return 1;                      //没有等到应答信号,读一个字节失败
    228            }
    229            I2C_C1_REG(I2Cx[I2Cn]) &= 0xef;           //TX = 0,MCU设置为接收模式    
    230            *Data = I2C_D_REG(I2Cx[I2Cn]);            //读出IIC1D,准备接收数据   
    231            if (hw_wait('T',MoudleNum))              //等待一个字节数据传送完成  
    232            {  
    233              return 1;                      //没有传送成功,读一个字节失败  
    234            }
    235            hw_send_signal('O',MoudleNum);           //发送停止信号    
    236            *Data = I2C_D_REG(I2Cx[I2Cn]);            //读出接收到的一个数据    
    237          
    238            return 0;                          //正确接收到一个字节数据
    239          }
    240          */
    241          

   \                                 In section .text, align 2, keep-with-next
    242          uint8 i2c_readaddr(I2Cn i2cn, uint8 SlaveID, uint8 Addr)
    243          {
   \                     i2c_readaddr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    244              uint8 result;
    245              /* send start signal */
    246              i2c_start(i2cn);
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x....             LDR.N    R0,??DataTable3_3
   \   0000000C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000010   0x7880             LDRB     R0,[R0, #+2]
   \   00000012   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x....             LDR.N    R1,??DataTable3_3
   \   0000001A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001E   0x7088             STRB     R0,[R1, #+2]
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x....             LDR.N    R0,??DataTable3_3
   \   00000024   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000028   0x7880             LDRB     R0,[R0, #+2]
   \   0000002A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x....             LDR.N    R1,??DataTable3_3
   \   00000032   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000036   0x7088             STRB     R0,[R1, #+2]
    247              /* send ID with W/R bit */
    248              //i2c_set_tx(i2cn);//设置为主机写从机读模式
    249              i2c_write(i2cn, ( SlaveID << 1 ) | I2C_MWSR);
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x....             LDR.N    R0,??DataTable3_3
   \   0000003C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000040   0x0069             LSLS     R1,R5,#+1
   \   00000042   0x7101             STRB     R1,[R0, #+4]
    250              LPLD_I2C_WaitAck(i2cn,1);
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       LPLD_I2C_WaitAck
    251          
    252              /* Write Register Address */
    253              //i2c_set_tx(i2cn);//设置为主机写从机读模式
    254              i2c_write(i2cn, Addr);
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x....             LDR.N    R0,??DataTable3_3
   \   00000052   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000056   0x7106             STRB     R6,[R0, #+4]
    255              LPLD_I2C_WaitAck(i2cn,1);
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x.... 0x....      BL       LPLD_I2C_WaitAck
    256              
    257              /* Do a repeated start */
    258              i2c_restart(i2cn);
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x....             LDR.N    R0,??DataTable3_3
   \   00000066   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000006A   0x7880             LDRB     R0,[R0, #+2]
   \   0000006C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000070   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000072   0x....             LDR.N    R1,??DataTable3_3
   \   00000074   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000078   0x7088             STRB     R0,[R1, #+2]
    259          
    260              /* Send Slave Address */
    261              //i2c_set_tx(i2cn);//设置为主机写从机读模式
    262              i2c_write(i2cn, ( SlaveID << 1) | I2C_MRSW );
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x....             LDR.N    R0,??DataTable3_3
   \   0000007E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000082   0x0069             LSLS     R1,R5,#+1
   \   00000084   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000088   0x7101             STRB     R1,[R0, #+4]
    263              LPLD_I2C_WaitAck(i2cn,1);
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x.... 0x....      BL       LPLD_I2C_WaitAck
    264              
    265              /* Put in Rx Mode */
    266              i2c_set_rx(i2cn);//设置为主机读从机写模式
   \   00000094   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000096   0x....             LDR.N    R0,??DataTable3_3
   \   00000098   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000009C   0x7880             LDRB     R0,[R0, #+2]
   \   0000009E   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   000000A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A4   0x....             LDR.N    R1,??DataTable3_3
   \   000000A6   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000AA   0x7088             STRB     R0,[R1, #+2]
    267              LPLD_I2C_WaitAck(i2cn,0);
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x.... 0x....      BL       LPLD_I2C_WaitAck
    268          
    269              /* Turn off ACK since this is second to last byte being read*/
    270              //i2c_dis_ack(i2cn); //不应答
    271          
    272              /* Dummy read 虚假读取*/
    273              result = I2C_D_REG(I2Cx[i2cn]);
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0x....             LDR.N    R0,??DataTable3_3
   \   000000BA   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000BE   0x7905             LDRB     R5,[R0, #+4]
    274              LPLD_I2C_WaitAck(i2cn,1);
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C6   0x.... 0x....      BL       LPLD_I2C_WaitAck
    275              
    276              /* Send stop since about to read last byte */
    277              i2c_stop(i2cn);
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0x....             LDR.N    R0,??DataTable3_3
   \   000000CE   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000D2   0x7880             LDRB     R0,[R0, #+2]
   \   000000D4   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000000D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DA   0x....             LDR.N    R1,??DataTable3_3
   \   000000DC   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000E0   0x7088             STRB     R0,[R1, #+2]
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0x....             LDR.N    R0,??DataTable3_3
   \   000000E6   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000EA   0x7880             LDRB     R0,[R0, #+2]
   \   000000EC   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0x....             LDR.N    R1,??DataTable3_3
   \   000000F4   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000F8   0x7088             STRB     R0,[R1, #+2]
    278          
    279              /* Read byte */
    280              result = I2C_D_REG(I2Cx[i2cn]);
   \   000000FA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FC   0x....             LDR.N    R0,??DataTable3_3
   \   000000FE   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000102   0x7900             LDRB     R0,[R0, #+4]
   \   00000104   0x0005             MOVS     R5,R0
    281          
    282              return (uint8)result;
   \   00000106   0x0028             MOVS     R0,R5
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0xBD70             POP      {R4-R6,PC}       ;; return
    283          }
    284          

   \                                 In section .text, align 2, keep-with-next
    285          void i2c_writeaddr(I2Cn i2cn, uint8 SlaveID, uint8 Addr, uint8 Data)
    286          {
   \                     i2c_writeaddr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001E             MOVS     R6,R3
    287              
    288              
    289              /* send start signal */
    290              i2c_start(i2cn);
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x....             LDR.N    R0,??DataTable3_3
   \   0000000C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000010   0x7880             LDRB     R0,[R0, #+2]
   \   00000012   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x....             LDR.N    R2,??DataTable3_3
   \   0000001A   0xF852 0x2024      LDR      R2,[R2, R4, LSL #+2]
   \   0000001E   0x7090             STRB     R0,[R2, #+2]
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x....             LDR.N    R0,??DataTable3_3
   \   00000024   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000028   0x7880             LDRB     R0,[R0, #+2]
   \   0000002A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x....             LDR.N    R2,??DataTable3_3
   \   00000032   0xF852 0x2024      LDR      R2,[R2, R4, LSL #+2]
   \   00000036   0x7090             STRB     R0,[R2, #+2]
    291              /* send ID with W/R bit */
    292              //i2c_set_tx(i2cn);//设置为主机写从机读模式
    293              i2c_write(i2cn, ( SlaveID << 1 ) | I2C_MWSR);
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x....             LDR.N    R0,??DataTable3_3
   \   0000003C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x7101             STRB     R1,[R0, #+4]
    294              LPLD_I2C_WaitAck(i2cn,1);                        //等待应答信号
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       LPLD_I2C_WaitAck
    295              
    296              //i2c_set_tx(i2cn);//设置为主机写从机读模式
    297              i2c_write(i2cn,Addr);                       //写访问地址
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x....             LDR.N    R0,??DataTable3_3
   \   00000052   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000056   0x7105             STRB     R5,[R0, #+4]
    298              LPLD_I2C_WaitAck(i2cn,1);                        //等待应答信号
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x.... 0x....      BL       LPLD_I2C_WaitAck
    299          
    300              //i2c_set_tx(i2cn);//设置为主机写从机读模式
    301              i2c_write(i2cn,Data);                       //写数据
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x....             LDR.N    R0,??DataTable3_3
   \   00000066   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000006A   0x7106             STRB     R6,[R0, #+4]
    302              LPLD_I2C_WaitAck(i2cn,1);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       LPLD_I2C_WaitAck
    303          
    304              i2c_stop(i2cn);
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0x....             LDR.N    R0,??DataTable3_3
   \   0000007A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000007E   0x7880             LDRB     R0,[R0, #+2]
   \   00000080   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x....             LDR.N    R1,??DataTable3_3
   \   00000088   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000008C   0x7088             STRB     R0,[R1, #+2]
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x....             LDR.N    R0,??DataTable3_3
   \   00000092   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000096   0x7880             LDRB     R0,[R0, #+2]
   \   00000098   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x....             LDR.N    R1,??DataTable3_3
   \   000000A0   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000A4   0x7088             STRB     R0,[R1, #+2]
    305          
    306              i2c_pause();                                        //延时太短的话，可能写出错
   \   000000A6   0x.... 0x....      BL       i2c_pause
    307          }
   \   000000AA   0xBD70             POP      {R4-R6,PC}       ;; return
    308          
    309          /*************************************************************************
    310          *                             野火嵌入式开发工作室
    311          *
    312          *  函数名称：i2c_pause
    313          *  功能说明：延时，I2C读写后，需要延时一下
    314          *  参数说明：无
    315          *  函数返回：无
    316          *  修改时间：2012-1-20
    317          *  备    注：在官方基础上增大延时数
    318          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    319          void i2c_pause(void)
    320          {
    321              uint16 n;
    322              for(n = 1; n < 25000; n++)      //注意，这个数据太小，会导致读取错误。
   \                     i2c_pause: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xE001             B.N      ??i2c_pause_0
    323              {
    324                  asm("nop");
   \                     ??i2c_pause_1: (+1)
   \   00000004   0xBF00             nop
    325              }
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \                     ??i2c_pause_0: (+1)
   \   00000008   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   0xF246 0x11A8      MOVW     R1,#+25000
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xDBF8             BLT.N    ??i2c_pause_1
    326          }
   \   00000012   0x4770             BX       LR               ;; return
    327          

   \                                 In section .text, align 2, keep-with-next
    328          void LPLD_I2C_WaitAck(I2Cn i2cn,uint8_t is_wait)
    329          {
    330            uint16_t time_out;
    331            if(is_wait)
   \                     LPLD_I2C_WaitAck: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD10D             BNE.N    ??LPLD_I2C_WaitAck_0
    332            {
    333                while(!(I2C_S_REG(I2Cx[i2cn]) & I2C_S_IICIF_MASK))
    334                {
    335                  if(time_out>60000) //如果等待超时，强行退出
    336                    break;
    337                  else time_out++;
    338                }
    339                I2C_S_REG(I2Cx[i2cn]) |= I2C_S_IICIF_MASK;
    340            }
    341            else
    342            {
    343              //关闭I2C的ACK
    344              I2C_C1_REG(I2Cx[i2cn]) |= I2C_C1_TXAK_MASK; 
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x....             LDR.N    R1,??DataTable3_3
   \   0000000A   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000000E   0x7889             LDRB     R1,[R1, #+2]
   \   00000010   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x....             LDR.N    R2,??DataTable3_3
   \   00000018   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
    345            }
    346          }
   \                     ??LPLD_I2C_WaitAck_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   \                     ??LPLD_I2C_WaitAck_2: (+1)
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \                     ??LPLD_I2C_WaitAck_0: (+1)
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x....             LDR.N    R1,??DataTable3_3
   \   00000026   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000002A   0x78C9             LDRB     R1,[R1, #+3]
   \   0000002C   0x0789             LSLS     R1,R1,#+30
   \   0000002E   0xD404             BMI.N    ??LPLD_I2C_WaitAck_3
   \   00000030   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000032   0xF64E 0x2161      MOVW     R1,#+60001
   \   00000036   0x428A             CMP      R2,R1
   \   00000038   0xDBF2             BLT.N    ??LPLD_I2C_WaitAck_2
   \                     ??LPLD_I2C_WaitAck_3: (+1)
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x....             LDR.N    R1,??DataTable3_3
   \   0000003E   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000042   0x78C9             LDRB     R1,[R1, #+3]
   \   00000044   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x....             LDR.N    R2,??DataTable3_3
   \   0000004C   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000050   0x70C1             STRB     R1,[R0, #+3]
   \   00000052   0xE7E4             B.N      ??LPLD_I2C_WaitAck_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     I2Cx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40066002         DC32     0x40066002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x4004B028         DC32     0x4004b028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x4004B02C         DC32     0x4004b02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x40067002         DC32     0x40067002

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LPLD_I2C_WaitAck
      12   i2c_init
       0   i2c_pause
      16   i2c_readaddr
        16   -> LPLD_I2C_WaitAck
      16   i2c_writeaddr
        16   -> LPLD_I2C_WaitAck
        16   -> i2c_pause


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       8  I2Cx
      84  LPLD_I2C_WaitAck
     244  i2c_init
      20  i2c_pause
     268  i2c_readaddr
     172  i2c_writeaddr

 
   8 bytes in section .data
 820 bytes in section .text
 
 820 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none

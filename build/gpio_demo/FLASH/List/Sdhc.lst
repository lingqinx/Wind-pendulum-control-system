###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      15/Aug/2015  19:53:06 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\d #
#                    iskio\Sdhc.c                                             #
#    Command line =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\d #
#                    iskio\Sdhc.c -lCN C:\Users\Administrator\Desktop\MPU6050 #
#                    8.12\build\gpio_demo\FLASH\List\ -lB                     #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\ -o C:\Users\Administrator\Desktop\MPU6050 #
#                    8.12\build\gpio_demo\FLASH\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\IAR Systems\Embedded     #
#                    Workbench 6.5\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\ -I C:\Users\Administrator\Desktop\MPU60508.12\bui #
#                    ld\gpio_demo\..\..\src\common\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\cpu\ -I C:\Users\Administrator\Desktop\MPU6 #
#                    0508.12\build\gpio_demo\..\..\src\drivers\ -I            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\gpio\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\olcd\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\diskio\ -I                          #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\iospi\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\wdog\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\mcg\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\uart\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\lptmr\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\LED\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\fun\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\FTM\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\pit\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\DIPswitch\ -I                       #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\motor\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\laser\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\i2c\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\ADdevice\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\adc\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\serial_digtal_scope\ -I             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MMA845x\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\exti\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\dma\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\platforms\ -I C:\Users\Administrator\Deskto #
#                    p\MPU60508.12\build\gpio_demo\..\..\src\projects\ -I     #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\projects\gpio_demo\ -I                      #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MPU6050\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -Ol                          #
#    List file    =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\Sdhc.lst                                   #
#    Object file  =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\Obj\Sdhc.o                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\diskio\Sdhc.c
      1          //*******************************************************************************************
      2          //  MK60DN512ZVL(K/L/Q)10 Demo - Vectors, Ultra-Low Pwr UART 115200 Echo ISR, 50MHz ACLK
      3          //
      4          //           MK60DN512ZVL(K/L/Q)10
      5          //            -----------------
      6          //        /|\|              XIN|-
      7          //         | |                 | 32kHz
      8          //         --|RST          XOUT|-
      9          //           |                 |
     10          //           |                 |
     11          //           |           P1.1  |<----L1 
     12          //           |           P1.3  |<----L2
     13          //           |           P1.5  |<----L3
     14          //           |                 |
     15          //           |                 |
     16          //           |           P1.4  |---->H1 
     17          //           |           P1.2  |---->H2
     18          //           |           P1.0  |---->H3
     19          //           |                 |
     20          //           |                 |
     21          //
     22          //  Copyright (c) 2012.04  WH, All Rights Reserved.
     23          //  WebSite     : http://united-electronic.taobao.com/
     24          //  Email       : dragonhzw@163.com
     25          //  QQ群         : 226846867
     26          //  Description : The vectors module
     27          //  History     :                                                           
     28          //     [Author]   [Date]      [Version]    [Description]                     
     29          //     [1] dragonhzw   2012/04/09  Ver 1.0.0    Initial file.
     30          //
     31          //  Built with IAR Embedded Workbench for ARM 6.30  
     32          //***********************************************************************************************
     33          #include "K60_datatype.h"
     34          #include "common.h"
     35          #include "include.h"
     36          
     37          #ifdef  __cplusplus
     38          extern "C" {
     39          #endif
     40          
     41            //  u8  sdhc_dat_buffer1[512];      
     42            //  u8  sdhc_dat_buffer2[512] = {44,55,99,100,6,7,8,9,10,11,12,13,14,15,26,27,18,19,20};
     43          
     44            __ramfunc static void SetSysDividers(u32 uiOutDiv1, u32 uiOutDiv2, u32 uiOutDiv3, u32 uiOutDiv4);
     45          
     46          //SDHC命令，包括每条命令执行时的XFERTYP寄存器各个域的设置

   \                                 In section .rodata, align 4
     47          static const unsigned long ESDHC_COMMAND_XFERTYP[] = 
   \                     ESDHC_COMMAND_XFERTYP:
   \   00000000   0x00000000         DC32 0, 16777216, 34144256, 52035584, 67108864, 84017152, 102367232
   \              0x01000000   
   \              0x02090000   
   \              0x031A0000   
   \              0x04000000   
   \              0x05020000   
   \              0x061A0000   
   \   0000001C   0x071B0000         DC32 119209984, 135921664, 151584768, 168361984, 186253312, 215678976
   \              0x081A0000   
   \              0x09090000   
   \              0x0A090000   
   \              0x0B1A0000   
   \              0x0CDB0000   
   \   00000034   0x0D1A0000         DC32 219807744, 0, 251658240, 270139392, 286916608, 303693824, 0
   \              0x00000000   
   \              0x0F000000   
   \              0x101A0000   
   \              0x111A0000   
   \              0x121A0000   
   \              0x00000000   
   \   00000050   0x141A0000         DC32 337248256, 0, 370802688, 387579904, 404357120, 421134336
   \              0x00000000   
   \              0x161A0000   
   \              0x171A0000   
   \              0x181A0000   
   \              0x191A0000   
   \   00000068   0x1A1A0000         DC32 437911552, 454688768, 471531520, 488308736, 505020416, 0
   \              0x1B1A0000   
   \              0x1C1B0000   
   \              0x1D1B0000   
   \              0x1E1A0000   
   \              0x00000000   
   \   00000080   0x201A0000         DC32 538574848, 555352064, 572129280, 588906496, 605683712, 622460928
   \              0x211A0000   
   \              0x221A0000   
   \              0x231A0000   
   \              0x241A0000   
   \              0x251A0000   
   \   00000098   0x261B0000         DC32 639303680, 654442496, 672792576, 687996928, 706412544, 0, 0, 0, 0
   \              0x27020000   
   \              0x281A0000   
   \              0x29020000   
   \              0x2A1B0000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   000000BC   0x00000000         DC32 0, 0, 0, 0, 857341952, 874119168, 890896384, 0, 924450816
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x331A0000   
   \              0x341A0000   
   \              0x351A0000   
   \              0x00000000   
   \              0x371A0000   
   \   000000E0   0x381B0000         DC32 941293568, 0, 0, 0, 1008402432, 1025179648, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x3C1B0000   
   \              0x3D1B0000   
   \              0x00000000   
   \              0x00000000   
     48          {
     49              // CMD0
     50              SDHC_XFERTYP_CMDINX(ESDHC_CMD0) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     51              SDHC_XFERTYP_CMDINX(ESDHC_CMD1) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     52              SDHC_XFERTYP_CMDINX(ESDHC_CMD2) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     53              SDHC_XFERTYP_CMDINX(ESDHC_CMD3) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     54              SDHC_XFERTYP_CMDINX(ESDHC_CMD4) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     55              // CMD5 
     56              SDHC_XFERTYP_CMDINX(ESDHC_CMD5) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     57              SDHC_XFERTYP_CMDINX(ESDHC_CMD6) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     58              SDHC_XFERTYP_CMDINX(ESDHC_CMD7) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     59              SDHC_XFERTYP_CMDINX(ESDHC_CMD8) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     60              SDHC_XFERTYP_CMDINX(ESDHC_CMD9) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     61              // CMD10 
     62              SDHC_XFERTYP_CMDINX(ESDHC_CMD10) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     63              SDHC_XFERTYP_CMDINX(ESDHC_CMD11) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     64              SDHC_XFERTYP_CMDINX(ESDHC_CMD12) | SDHC_XFERTYP_CMDTYP(ESDHC_XFERTYP_CMDTYP_ABORT) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     65              SDHC_XFERTYP_CMDINX(ESDHC_CMD13) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     66              0,
     67              // CMD15 
     68              SDHC_XFERTYP_CMDINX(ESDHC_CMD15) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     69              SDHC_XFERTYP_CMDINX(ESDHC_CMD16) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     70              SDHC_XFERTYP_CMDINX(ESDHC_CMD17) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     71              SDHC_XFERTYP_CMDINX(ESDHC_CMD18) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     72              0,
     73              // CMD20 
     74              SDHC_XFERTYP_CMDINX(ESDHC_CMD20) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     75              0,
     76              SDHC_XFERTYP_CMDINX(ESDHC_ACMD22) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     77              SDHC_XFERTYP_CMDINX(ESDHC_ACMD23) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     78              SDHC_XFERTYP_CMDINX(ESDHC_CMD24) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     79              // CMD25 
     80              SDHC_XFERTYP_CMDINX(ESDHC_CMD25) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     81              SDHC_XFERTYP_CMDINX(ESDHC_CMD26) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     82              SDHC_XFERTYP_CMDINX(ESDHC_CMD27) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     83              SDHC_XFERTYP_CMDINX(ESDHC_CMD28) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     84              SDHC_XFERTYP_CMDINX(ESDHC_CMD29) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     85              // CMD30 
     86              SDHC_XFERTYP_CMDINX(ESDHC_CMD30) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     87              0,
     88              SDHC_XFERTYP_CMDINX(ESDHC_CMD32) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     89              SDHC_XFERTYP_CMDINX(ESDHC_CMD33) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     90              SDHC_XFERTYP_CMDINX(ESDHC_CMD34) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     91              // CMD35 
     92              SDHC_XFERTYP_CMDINX(ESDHC_CMD35) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     93              SDHC_XFERTYP_CMDINX(ESDHC_CMD36) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     94              SDHC_XFERTYP_CMDINX(ESDHC_CMD37) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     95              SDHC_XFERTYP_CMDINX(ESDHC_CMD38) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     96              SDHC_XFERTYP_CMDINX(ESDHC_CMD39) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     97              // CMD40 
     98              SDHC_XFERTYP_CMDINX(ESDHC_CMD40) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     99              SDHC_XFERTYP_CMDINX(ESDHC_ACMD41) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    100              SDHC_XFERTYP_CMDINX(ESDHC_CMD42) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    101              0,
    102              0,
    103              // CMD45 
    104              0,
    105              0,
    106              0,
    107              0,
    108              0,
    109              // CMD50 
    110              0,
    111              SDHC_XFERTYP_CMDINX(ESDHC_ACMD51) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    112              SDHC_XFERTYP_CMDINX(ESDHC_CMD52) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    113              SDHC_XFERTYP_CMDINX(ESDHC_CMD53) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    114              0,
    115              // CMD55 
    116              SDHC_XFERTYP_CMDINX(ESDHC_CMD55) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    117              SDHC_XFERTYP_CMDINX(ESDHC_CMD56) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    118              0,
    119              0,
    120              0,
    121              // CMD60 
    122              SDHC_XFERTYP_CMDINX(ESDHC_CMD60) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    123              SDHC_XFERTYP_CMDINX(ESDHC_CMD61) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    124              0,
    125              0
    126          };
    127          
    128          /***FUNC+*********************************************************************/
    129          /* Name   : PLL_Init                                                         */
    130          /* Descrp : Initialize PLL                                                   */
    131          /* Input  : None.                                                            */   
    132          /* Output : None.                                                            */
    133          /* Return : None.                                                            */   
    134          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          void PLL_Init(void)
    136          {
   \                     PLL_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    137          
    138              MCG_C2 = 0;                        // x x RANGE HGO EREFS LP IRCS
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40064001
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
    139                                                 // 0 0   00    0    0   0   0
    140                                                 // RANGE=00:Low frequency range selected for the crystal oscillator of 32 kHz to 40 kHz
    141                                                 // HGO  =0 :Configure crystal oscillator for low-power operation
    142                                                 // EREFS=0 :External reference clock requested 
    143              
    144              SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x40048034
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable8_1  ;; 0x40048034
   \   00000018   0x6008             STR      R0,[R1, #+0]
    145              LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x4007c008
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable8_2  ;; 0x4007c008
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    146              
    147              MCG_C1 = MCG_C1_CLKS(2) |          // CLKS FRDIV IREFS IRCLKEN IREFSTEN
    148                       MCG_C1_FRDIV(3);          //  10   011    1     0        0  
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40064000
   \   0000002E   0x2198             MOVS     R1,#+152
   \   00000030   0x7001             STRB     R1,[R0, #+0]
    149                                                 // CLKS =10 :External reference clock is selected
    150                                                 // FRDIV=011:Divide Factor is 8
    151              
    152              while (MCG_S & MCG_S_IREFST_MASK)  // wait until source of FLL reference clock is the external reference clock
   \                     ??PLL_Init_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40064006
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x06C0             LSLS     R0,R0,#+27
   \   0000003A   0xD4FA             BMI.N    ??PLL_Init_0
    153              {
    154                  ;  
    155              }
    156              
    157              while (((MCG_S & MCG_S_CLKST_MASK) // wait until external reference clock is selected
    158                    >> MCG_S_CLKST_SHIFT) != 0x2)
   \                     ??PLL_Init_1: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40064006
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD1F7             BNE.N    ??PLL_Init_1
    159              {
    160                  ;   
    161              }
    162              
    163              MCG_C5 = MCG_C5_PRDIV(0x18);       // x PLLCLKEN PLLSTEN PRDIV
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x40064004
   \   00000050   0x2118             MOVS     R1,#+24
   \   00000052   0x7001             STRB     R1,[R0, #+0]
    164                                                 // 0    0        0    11000
    165                                                 // PRDIV=11000:Divide Factor is 25 
    166                 
    167              SetSysDividers(0, 1, 1, 3);        // MCG=PLL, core=MCG, bus=MCG/2, FlexBus=MCG/2, Flash clock=MCG/4
   \   00000054   0x2303             MOVS     R3,#+3
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       SetSysDividers
    168              
    169              MCG_C6 = MCG_C6_PLLS_MASK |        // LOLIE PLLS CME VDIV  
    170                       MCG_C6_VDIV(24);          //   0    1    0  11000    
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x40064005
   \   00000064   0x2158             MOVS     R1,#+88
   \   00000066   0x7001             STRB     R1,[R0, #+0]
    171                                                 // PLLS=1    :PLL is selected 
    172                                                 // VDIV=11000:Multiply Factor is 48
    173                                                 // PLL = 2MHz x 48 = 96MHz
    174              
    175              while (!(MCG_S & MCG_S_PLLST_MASK))// wait until source of PLLS clock is PLL clock
   \                     ??PLL_Init_2: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40064006
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x0680             LSLS     R0,R0,#+26
   \   00000070   0xD5FA             BPL.N    ??PLL_Init_2
    176              {
    177                  ;   
    178              }
    179              
    180              while (!(MCG_S & MCG_S_LOCK_MASK)) // wait until PLL is locked
   \                     ??PLL_Init_3: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40064006
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x0640             LSLS     R0,R0,#+25
   \   0000007A   0xD5FA             BPL.N    ??PLL_Init_3
    181              {
    182                  ;
    183              }
    184              
    185              MCG_C1 &= ~MCG_C1_CLKS_MASK;       // Output of FLL or PLL is selected
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40064000
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x40064000
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
    186              
    187              while (((MCG_S & MCG_S_CLKST_MASK) // wait until Output of the PLL is selected 
    188                    >> MCG_S_CLKST_SHIFT) != 0x3)
   \                     ??PLL_Init_4: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40064006
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x2803             CMP      R0,#+3
   \   0000009A   0xD1F7             BNE.N    ??PLL_Init_4
    189              {
    190                  ;
    191              }
    192          }
   \   0000009C   0xBD01             POP      {R0,PC}          ;; return
    193          
    194          /***FUNC+*********************************************************************/
    195          /* Name   : SetSysDividers                                                   */
    196          /* Descrp : This routine must be placed in RAM.It is a                       */
    197          /*          workaround for errata e2448.Flash prefetch must                  */
    198          /*          be disabled when the flash clock divider is                      */
    199          /*          changed.This cannot be performed while executing                 */
    200          /*          out of flash.There must be a short delay after                   */
    201          /*          the clock dividers are changed before prefetch                   */
    202          /*          can be re-enabled.                                               */
    203          /* Input  : None.                                                            */   
    204          /* Output : None.                                                            */
    205          /* Return : None.                                                            */   
    206          /***FUNC-*********************************************************************/

   \                                 In section .textrw, align 4, keep-with-next
    207          __ramfunc static void SetSysDividers(u32 uiOutDiv1, u32 uiOutDiv2, u32 uiOutDiv3, u32 uiOutDiv4)
    208          {
   \                     SetSysDividers: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    209          
    210              u32 uiTemp;
    211            
    212              int  i;
    213            
    214           
    215              // store present value of FMC_PFAPR
    216              uiTemp = FMC_PFAPR; 
   \   00000002   0x4C10             LDR.N    R4,??SetSysDividers_0  ;; 0x4001f000
   \   00000004   0x6824             LDR      R4,[R4, #+0]
    217            
    218              // set M0PFD through M7PFD to 1 to disable prefetch
    219              FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    220                        | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    221                        | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
   \   00000006   0x4D0F             LDR.N    R5,??SetSysDividers_0  ;; 0x4001f000
   \   00000008   0x682D             LDR      R5,[R5, #+0]
   \   0000000A   0xF455 0x057F      ORRS     R5,R5,#0xFF0000
   \   0000000E   0x4E0D             LDR.N    R6,??SetSysDividers_0  ;; 0x4001f000
   \   00000010   0x6035             STR      R5,[R6, #+0]
    222            
    223              // set clock dividers to desired value  
    224              SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(uiOutDiv1) | SIM_CLKDIV1_OUTDIV2(uiOutDiv2) 
    225                          | SIM_CLKDIV1_OUTDIV3(uiOutDiv3) | SIM_CLKDIV1_OUTDIV4(uiOutDiv4);
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xF011 0x6170      ANDS     R1,R1,#0xF000000
   \   00000018   0xEA51 0x7000      ORRS     R0,R1,R0, LSL #+28
   \   0000001C   0x0511             LSLS     R1,R2,#+20
   \   0000001E   0xF411 0x0170      ANDS     R1,R1,#0xF00000
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x0419             LSLS     R1,R3,#+16
   \   00000026   0xF411 0x2170      ANDS     R1,R1,#0xF0000
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0x4906             LDR.N    R1,??SetSysDividers_0+0x4  ;; 0x40048044
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    226          
    227              // wait for dividers to change
    228              for (i = 0; i < uiOutDiv4; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE000             B.N      ??SetSysDividers_1
   \                     ??SetSysDividers_2: (+1)
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \                     ??SetSysDividers_1: (+1)
   \   00000036   0x4298             CMP      R0,R3
   \   00000038   0xD3FC             BCC.N    ??SetSysDividers_2
    229              {
    230                  ;   
    231              }
    232           
    233              // re-store original value of FMC_PFAPR
    234              FMC_PFAPR = uiTemp; 
   \   0000003A   0x4802             LDR.N    R0,??SetSysDividers_0  ;; 0x4001f000
   \   0000003C   0x6004             STR      R4,[R0, #+0]
    235            
    236          } 
   \   0000003E   0xBC70             POP      {R4-R6}
   \   00000040   0x4770             BX       LR               ;; return
   \   00000042   0xBF00             Nop      
   \                     ??SetSysDividers_0:
   \   00000044   0x4001F000         DC32     0x4001f000
   \   00000048   0x40048044         DC32     0x40048044
    237          /***FUNC+*********************************************************************/
    238          /* Name   : main                                                             */
    239          /* Descrp :                                                                  */
    240          /* Input  : None.                                                            */   
    241          /* Output : None.                                                            */
    242          /* Return : None.                                                            */   
    243          /***FUNC-*********************************************************************/
    244          #if 0
    245          
    246          void main(void)
    247          {
    248              short sIndex =0;
    249              u32 i = 0;
    250              DRESULT sd_state;    //SD卡操作状态
    251          
    252          
    253              /*********************************************************/
    254              /* Close all irq.                                        */
    255              /*********************************************************/
    256              DisableInterrupts;  
    257              
    258              /*********************************************************/
    259              /* Watchdog disable.                                     */
    260              /*********************************************************/
    261              WatchdogDisable();
    262          
    263              /*********************************************************/
    264              /*Copy the vector table to RAM .                         */
    265              /*********************************************************/
    266              VECTableInit();
    267          
    268              /*
    269              * Enable all of the port clocks. These have to be enabled to configure
    270              * pin muxing options, so most code will need all of these on anyway.
    271              */
    272              SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
    273                                | SIM_SCGC5_PORTB_MASK
    274                                | SIM_SCGC5_PORTC_MASK
    275                                | SIM_SCGC5_PORTD_MASK
    276                                | SIM_SCGC5_PORTE_MASK );
    277              /*********************************************************/
    278              /*Initialize PLL.                                        */
    279              /*********************************************************/ 
    280              PLL_Init();
    281          
    282              /*********************************************************/
    283              /*Init Uart3 BaudRate and clk .                          */
    284              /*********************************************************/
    285              UART_Init(PERIPH_SYS_CLK, BAUD_RATE_115200, UART4);
    286              
    287              sd_state = disk_initialize(0); 
    288              /*********************************************************/
    289              /* open all irq.                                         */
    290              /*********************************************************/
    291              EnableInterrupts;
    292              
    293              uartPrintf("\r\n");
    294              uartPrintf("|********************************************************************|\r\n");
    295              uartPrintf("|******MK60DN512ZVL(K/L/Q)10 development board SD Card Example!******|\r\n");
    296              uartPrintf("|********************************************************************|\r\n");    
    297          
    298              //对初始化操作进行处理
    299              if (RES_OK == sd_state)
    300              {
    301                  uartPrintf("SD init success.\r\n");
    302              }
    303              else
    304              {
    305                  uartPrintf("sd_state :%d \r\n", sd_state);
    306                  uartPrintf("SD init failure.\r\n");
    307              }
    308              
    309              while(1)
    310              {
    311                  
    312                  uartPrintf("\r\nPlease Select Enter Number[1~2]: ");
    313                  sIndex = Uart_GetIntNum();
    314                  uartPrintf("\r\n");
    315                  if(0x01 == sIndex)
    316                  {
    317                      sd_state = disk_read(0,sdhc_dat_buffer1,0,1);//读操作，更新SD操作状态
    318                      //对读操作进行处理
    319                      if (RES_OK == sd_state)
    320                      {
    321                          uartPrintf("Read disk success.\r\n");
    322                          uartPrintf("SD data: \r\n");
    323                          for(i = 0;i < 512;i++) //若读成功，打印该扇区内容
    324                          {
    325                              uartPrintf("%02X ", sdhc_dat_buffer1[i]);
    326                          }  
    327                          uartPrintf("\r\n");
    328                      }
    329                      else
    330                      {
    331                          uartPrintf("Read disk failed!\n\r");
    332                      }
    333                  }
    334          
    335                  else if(0x02 == sIndex)
    336                  {
    337                      sd_state = disk_write(0, sdhc_dat_buffer2, 0, 1);  //写操作，SD操作更新状态
    338                      //对读操作进行处理
    339                      if (RES_OK == sd_state)
    340                      {
    341                          uartPrintf("Read disk success.\r\n");
    342                          uartPrintf("SD data: \r\n");
    343                          for(i = 0;i < 512;i++) //若读成功，打印该扇区内容
    344                          {
    345                              uartPrintf("%02X ", sdhc_dat_buffer1[i]);
    346                          }  
    347                          uartPrintf("\r\n");
    348                      }
    349                      else
    350                      {
    351                          uartPrintf("Read disk failed!\n\r");
    352                      }
    353                  }
    354              
    355                
    356              }
    357              
    358          }
    359          
    360          #endif
    361          
    362          //=========================================================================
    363          //函数名称：hw_sdhc_init                                                        
    364          //功能概要：初始化SDHC模块。                                                
    365          //参数说明：coreClk：内核时钟                                                    
    366          //         baud：SDHC通信频率                                 
    367          //函数返回：成功时返回：ESDHC_OK;其他返回值为错误。                                                               
    368          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    369          u32 SDHC_init(u32 coreClk, u32 baud)
    370          {
   \                     SDHC_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    371              SDHC_Card.CARD_TYPE = ESDHC_CARD_NONE;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable8_7
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x7013             STRB     R3,[R2, #+0]
    372                  
    373              //使能SDHC模块的时钟门
    374              SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable8_8  ;; 0x40048030
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0xF452 0x3200      ORRS     R2,R2,#0x20000
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable8_8  ;; 0x40048030
   \   00000018   0x601A             STR      R2,[R3, #+0]
    375              
    376              //复位SDHC
    377              SDHC_SYSCTL = SDHC_SYSCTL_RSTA_MASK | SDHC_SYSCTL_SDCLKFS(0x80);    
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable8_9  ;; 0x400b102c
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable8_10  ;; 0x1008000
   \   00000022   0x6013             STR      R3,[R2, #+0]
    378              while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA_MASK){};
   \                     ??SDHC_init_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable8_9  ;; 0x400b102c
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x01D2             LSLS     R2,R2,#+7
   \   0000002C   0xD4FA             BMI.N    ??SDHC_init_0
    379              
    380              //初始化SDHC相关寄存器
    381              SDHC_VENDOR = 0;
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable8_11  ;; 0x400b10c0
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x6013             STR      R3,[R2, #+0]
    382              SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable8_12  ;; 0x400b1004
   \   0000003A   0xF45F 0x3381      MOVS     R3,#+66048
   \   0000003E   0x6013             STR      R3,[R2, #+0]
    383              SDHC_PROCTL = SDHC_PROCTL_EMODE(ESDHC_PROCTL_EMODE_INVARIANT) 
    384                          | SDHC_PROCTL_D3CD_MASK; 
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable8_13  ;; 0x400b1028
   \   00000044   0x2328             MOVS     R3,#+40
   \   00000046   0x6013             STR      R3,[R2, #+0]
    385              SDHC_WML = SDHC_WML_RDWML(1) | SDHC_WML_WRWML(1);
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable8_14  ;; 0x400b1044
   \   0000004C   0xF05F 0x1301      MOVS     R3,#+65537
   \   00000050   0x6013             STR      R3,[R2, #+0]
    386              
    387              //设置SDHC模块的通信速率
    388              SDHC_set_baudrate (coreClk,baud);
   \   00000052   0x.... 0x....      BL       SDHC_set_baudrate
    389              
    390              //检查CMD通道和DAT通道是否准备就绪
    391              while (SDHC_PRSSTAT & (  SDHC_PRSSTAT_CIHB_MASK 
    392                                     | SDHC_PRSSTAT_CDIHB_MASK)){};
   \                     ??SDHC_init_1: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable8_15  ;; 0x400b1024
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF010 0x0F03      TST      R0,#0x3
   \   00000060   0xD1F9             BNE.N    ??SDHC_init_1
    393          
    394              //设置复用引脚功能为SDHC
    395              PORTE_PCR(0) = 0xFFFF & (   PORT_PCR_MUX(4) 
    396                                        | PORT_PCR_PS_MASK 
    397                                        | PORT_PCR_PE_MASK 
    398                                        | PORT_PCR_DSE_MASK); // ESDHC.D1  
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable8_16  ;; 0x4004d000
   \   00000066   0xF240 0x4143      MOVW     R1,#+1091
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    399              PORTE_PCR(1) = 0xFFFF & (   PORT_PCR_MUX(4) 
    400                                        | PORT_PCR_PS_MASK 
    401                                        | PORT_PCR_PE_MASK 
    402                                        | PORT_PCR_DSE_MASK); // ESDHC.D0  
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable8_17  ;; 0x4004d004
   \   00000070   0xF240 0x4143      MOVW     R1,#+1091
   \   00000074   0x6001             STR      R1,[R0, #+0]
    403              PORTE_PCR(2) = 0xFFFF & (   PORT_PCR_MUX(4) 
    404                                        | PORT_PCR_DSE_MASK); // ESDHC.CLK 
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable8_18  ;; 0x4004d008
   \   0000007A   0xF44F 0x6188      MOV      R1,#+1088
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    405              PORTE_PCR(3) = 0xFFFF & (   PORT_PCR_MUX(4) 
    406                                        | PORT_PCR_PS_MASK 
    407                                        | PORT_PCR_PE_MASK 
    408                                        | PORT_PCR_DSE_MASK); // ESDHC.CMD 
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable8_19  ;; 0x4004d00c
   \   00000084   0xF240 0x4143      MOVW     R1,#+1091
   \   00000088   0x6001             STR      R1,[R0, #+0]
    409              PORTE_PCR(4) = 0xFFFF & (   PORT_PCR_MUX(4) 
    410                                        | PORT_PCR_PS_MASK 
    411                                        | PORT_PCR_PE_MASK 
    412                                        | PORT_PCR_DSE_MASK); // ESDHC.D3  
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable8_20  ;; 0x4004d010
   \   0000008E   0xF240 0x4143      MOVW     R1,#+1091
   \   00000092   0x6001             STR      R1,[R0, #+0]
    413              PORTE_PCR(5) = 0xFFFF & (   PORT_PCR_MUX(4) 
    414                                        | PORT_PCR_PS_MASK 
    415                                        | PORT_PCR_PE_MASK 
    416                                        | PORT_PCR_DSE_MASK);  // ESDHC.D2  
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable8_21  ;; 0x4004d014
   \   00000098   0xF240 0x4143      MOVW     R1,#+1091
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    417              
    418              //清除SDHC模块的中断标志
    419              SDHC_IRQSTAT = 0xFFFF;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable8_22  ;; 0x400b1030
   \   000000A2   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000A6   0x6001             STR      R1,[R0, #+0]
    420              //使能中断位
    421              SDHC_IRQSTATEN = SDHC_IRQSTATEN_DEBESEN_MASK 
    422                             | SDHC_IRQSTATEN_DCESEN_MASK 
    423                             | SDHC_IRQSTATEN_DTOESEN_MASK 
    424                             | SDHC_IRQSTATEN_CIESEN_MASK 
    425                             | SDHC_IRQSTATEN_CEBESEN_MASK 
    426                             | SDHC_IRQSTATEN_CCESEN_MASK 
    427                             | SDHC_IRQSTATEN_CTOESEN_MASK 
    428                             | SDHC_IRQSTATEN_BRRSEN_MASK 
    429                             | SDHC_IRQSTATEN_BWRSEN_MASK 
    430                             | SDHC_IRQSTATEN_CRMSEN_MASK
    431                             | SDHC_IRQSTATEN_TCSEN_MASK 
    432                             | SDHC_IRQSTATEN_CCSEN_MASK;
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable8_23  ;; 0x400b1034
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable8_24  ;; 0x7f00b3
   \   000000B0   0x6001             STR      R1,[R0, #+0]
    433              
    434              //80个时钟周期的初始化
    435              SDHC_SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x400b102c
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable8_9  ;; 0x400b102c
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    436              while (SDHC_SYSCTL & SDHC_SYSCTL_INITA_MASK){};
   \                     ??SDHC_init_2: (+1)
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x400b102c
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0x0100             LSLS     R0,R0,#+4
   \   000000CA   0xD4FA             BMI.N    ??SDHC_init_2
    437          
    438              //检查卡是否已经插入
    439              if (SDHC_PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable8_15  ;; 0x400b1024
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x03C0             LSLS     R0,R0,#+15
   \   000000D4   0xD503             BPL.N    ??SDHC_init_3
    440              {
    441                  SDHC_Card.CARD_TYPE = ESDHC_CARD_UNKNOWN;
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   000000DA   0x2101             MOVS     R1,#+1
   \   000000DC   0x7001             STRB     R1,[R0, #+0]
    442              }
    443              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??SDHC_init_3: (+1)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable8_22  ;; 0x400b1030
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable8_22  ;; 0x400b1030
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    444              
    445              return ESDHC_OK;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xBD02             POP      {R1,PC}          ;; return
    446          }
    447          
    448          //=========================================================================
    449          //函数名称：SDHC_receive_block                                                         
    450          //功能概要：接收n个字节                                                 
    451          //参数说明：buff: 接收缓冲区                                                 
    452          //		   btr:接收长度                                                     
    453          //函数返回： 1:成功;0:失败                                                    
    454          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    455          u32 SDHC_receive_block (u8 *buff,u32 btr)
    456          {
   \                     SDHC_receive_block: (+1)
   \   00000000   0xB410             PUSH     {R4}
    457              u32 bytes, i, j;
    458              u32 *ptr = (u32*)buff;
    459              
    460              //当可识别的卡插入后，接收数据前，检测DAT通道是否忙（正在使用中）
    461              if (    (SDHC_Card.CARD_TYPE == ESDHC_CARD_SD) 
    462                   || (SDHC_Card.CARD_TYPE == ESDHC_CARD_SDHC) 
    463                   || (SDHC_Card.CARD_TYPE == ESDHC_CARD_MMC) 
    464                   || (SDHC_Card.CARD_TYPE == ESDHC_CARD_CEATA))
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable8_7
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD00E             BEQ.N    ??SDHC_receive_block_0
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable8_7
   \   00000010   0x7812             LDRB     R2,[R2, #+0]
   \   00000012   0x2A03             CMP      R2,#+3
   \   00000014   0xD009             BEQ.N    ??SDHC_receive_block_0
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable8_7
   \   0000001A   0x7812             LDRB     R2,[R2, #+0]
   \   0000001C   0x2A07             CMP      R2,#+7
   \   0000001E   0xD004             BEQ.N    ??SDHC_receive_block_0
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable8_7
   \   00000024   0x7812             LDRB     R2,[R2, #+0]
   \   00000026   0x2A08             CMP      R2,#+8
   \   00000028   0xD104             BNE.N    ??SDHC_receive_block_1
    465              {
    466                  while (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA_MASK){};
   \                     ??SDHC_receive_block_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable8_15  ;; 0x400b1024
   \   0000002E   0x6812             LDR      R2,[R2, #+0]
   \   00000030   0x0752             LSLS     R2,R2,#+29
   \   00000032   0xD4FA             BMI.N    ??SDHC_receive_block_0
    467              }    
    468              
    469              //读取数据时，每次读取4个字节
    470              bytes = btr;
   \                     ??SDHC_receive_block_1: (+1)
   \   00000034   0xE000             B.N      ??SDHC_receive_block_2
    471              while (bytes)
    472              {
    473                  i = bytes > 512 ? 512 : bytes;
    474                  for (j = (i + 3) >> 2; j != 0; j--)
    475                  {
    476                      if (SDHC_IRQSTAT & (    SDHC_IRQSTAT_DEBE_MASK 
    477                                            | SDHC_IRQSTAT_DCE_MASK 
    478                                            | SDHC_IRQSTAT_DTOE_MASK))
    479                      {
    480                          SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK 
    481                                        | SDHC_IRQSTAT_DCE_MASK 
    482                                        | SDHC_IRQSTAT_DTOE_MASK 
    483                                        | SDHC_IRQSTAT_BRR_MASK;
    484                          return 0;
    485                      }
    486                      
    487                      while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN_MASK)){};
    488          
    489                      *ptr++ = SDHC_DATPORT;
    490                  }
    491                  bytes -= i;
   \                     ??SDHC_receive_block_3: (+1)
   \   00000036   0x1A89             SUBS     R1,R1,R2
   \                     ??SDHC_receive_block_2: (+1)
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD028             BEQ.N    ??SDHC_receive_block_4
   \   0000003C   0xF5B1 0x7F00      CMP      R1,#+512
   \   00000040   0xD902             BLS.N    ??SDHC_receive_block_5
   \   00000042   0xF44F 0x7200      MOV      R2,#+512
   \   00000046   0xE000             B.N      ??SDHC_receive_block_6
   \                     ??SDHC_receive_block_5: (+1)
   \   00000048   0x000A             MOVS     R2,R1
   \                     ??SDHC_receive_block_6: (+1)
   \   0000004A   0x1CD3             ADDS     R3,R2,#+3
   \   0000004C   0x089B             LSRS     R3,R3,#+2
   \   0000004E   0xE00A             B.N      ??SDHC_receive_block_7
   \                     ??SDHC_receive_block_8: (+1)
   \   00000050   0x.... 0x....      LDR.W    R4,??DataTable8_15  ;; 0x400b1024
   \   00000054   0x6824             LDR      R4,[R4, #+0]
   \   00000056   0x0524             LSLS     R4,R4,#+20
   \   00000058   0xD5FA             BPL.N    ??SDHC_receive_block_8
   \   0000005A   0x.... 0x....      LDR.W    R4,??DataTable8_25  ;; 0x400b1020
   \   0000005E   0x6824             LDR      R4,[R4, #+0]
   \   00000060   0x6004             STR      R4,[R0, #+0]
   \   00000062   0x1D00             ADDS     R0,R0,#+4
   \   00000064   0x1E5B             SUBS     R3,R3,#+1
   \                     ??SDHC_receive_block_7: (+1)
   \   00000066   0x2B00             CMP      R3,#+0
   \   00000068   0xD0E5             BEQ.N    ??SDHC_receive_block_3
   \   0000006A   0x.... 0x....      LDR.W    R4,??DataTable8_22  ;; 0x400b1030
   \   0000006E   0x6824             LDR      R4,[R4, #+0]
   \   00000070   0xF414 0x0FE0      TST      R4,#0x700000
   \   00000074   0xD0EC             BEQ.N    ??SDHC_receive_block_8
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable8_22  ;; 0x400b1030
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000080   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable8_22  ;; 0x400b1030
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??SDHC_receive_block_9
    492              }
    493              
    494              return 1;       // Return with success     
   \                     ??SDHC_receive_block_4: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??SDHC_receive_block_9: (+1)
   \   00000090   0xBC10             POP      {R4}
   \   00000092   0x4770             BX       LR               ;; return
    495          }
    496          
    497          //=========================================================================
    498          //函数名称：SDHC_send_block                                                         
    499          //功能概要：发送n个字节                                                 
    500          //参数说明：buff: 发送缓冲区                                                 
    501          //		   btr:发送长度                                                     
    502          //函数返回： 1:成功;0:失败                                                    
    503          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    504          u32 SDHC_send_block (const u8 *buff,u32 btr)
    505          {
   \                     SDHC_send_block: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    506              u32  bytes, i;
    507              //u32 *ptr = (u32*)buff;
    508             
    509              //读取数据时，每次读取4个字节
    510              bytes = btr;
    511              //uartPrintf("%d\n",bytes);
    512              while (bytes)
   \                     ??SDHC_send_block_0: (+1)
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xD02D             BEQ.N    ??SDHC_send_block_1
    513              {
    514                //uartPrintf("%d\n",c);
    515                 u32 *ptr = (u32*)buff;
   \   0000000A   0x0025             MOVS     R5,R4
    516                 // i = bytes > 512 ? 512 : bytes;
    517                i=512;
   \   0000000C   0xF44F 0x7700      MOV      R7,#+512
    518          #if PRINT
    519                  //uartPrintf("%d\n",bytes);
    520          #endif 
    521                  bytes -= i;
   \   00000010   0x1BF6             SUBS     R6,R6,R7
    522                  for (i = (i + 3) >> 2; i != 0; i--)
   \   00000012   0x1CF8             ADDS     R0,R7,#+3
   \   00000014   0x0887             LSRS     R7,R0,#+2
   \   00000016   0xE00E             B.N      ??SDHC_send_block_2
    523                  {
    524                      if (SDHC_IRQSTAT & (    SDHC_IRQSTAT_DEBE_MASK 
    525                                            | SDHC_IRQSTAT_DCE_MASK 
    526                                            | SDHC_IRQSTAT_DTOE_MASK))
    527                      {
    528                          SDHC_IRQSTAT    |= SDHC_IRQSTAT_DEBE_MASK 
    529                                          | SDHC_IRQSTAT_DCE_MASK 
    530                                          | SDHC_IRQSTAT_DTOE_MASK 
    531                                          | SDHC_IRQSTAT_BWR_MASK;
    532          #if PRINT
    533                          
    534          #endif 
    535                         uartPrintf("错误返回1\n");
    536                        return 0;
    537                      }
    538                      while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
    539                      {
    540                        uartPrintf("等待数据\n");
   \                     ??SDHC_send_block_3: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable8_26
   \   0000001C   0x.... 0x....      BL       uartPrintf
    541          #if PRINT
    542                        //
    543          #endif
    544                      }  //等待数据准备好
   \                     ??SDHC_send_block_4: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable8_15  ;; 0x400b1024
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0540             LSLS     R0,R0,#+21
   \   00000028   0xD5F6             BPL.N    ??SDHC_send_block_3
    545          
    546                      
    547          
    548                     
    549                      SDHC_DATPORT = *ptr++;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable8_25  ;; 0x400b1020
   \   0000002E   0x6829             LDR      R1,[R5, #+0]
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0x1D2D             ADDS     R5,R5,#+4
   \   00000034   0x1E7F             SUBS     R7,R7,#+1
   \                     ??SDHC_send_block_2: (+1)
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xD0E5             BEQ.N    ??SDHC_send_block_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable8_22  ;; 0x400b1030
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF410 0x0FE0      TST      R0,#0x700000
   \   00000044   0xD0EC             BEQ.N    ??SDHC_send_block_4
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable8_22  ;; 0x400b1030
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000050   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable8_22  ;; 0x400b1030
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable8_27
   \   0000005E   0x.... 0x....      BL       uartPrintf
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE004             B.N      ??SDHC_send_block_5
    550                     // 
    551                     
    552                     
    553                      
    554                      
    555                    
    556                  }   
    557                //  uartPrintf("%d\n",c);
    558                  
    559                 //     c--;
    560                //  uartPrintf("%d\n",c);  
    561                      
    562          #if PRINT
    563                  //uartPrintf("%d\n",bytes);
    564          #endif
    565              
    566              }
    567              
    568               uartPrintf("所有数据发送完毕\n");
   \                     ??SDHC_send_block_1: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable8_28
   \   0000006A   0x.... 0x....      BL       uartPrintf
    569                        
    570          #if PRINT
    571              
    572          #endif    
    573                   
    574              
    575              
    576              
    577          	return 1;
   \   0000006E   0x2001             MOVS     R0,#+1
   \                     ??SDHC_send_block_5: (+1)
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    578          }
    579          
    580          //=========================================================================
    581          //函数名称：SDHC_ioctl
    582          //功能概要：配置SDHC模块
    583          //参数说明：cmd: 配置命令
    584          //		   param_ptr:数据指针
    585          //函数返回： 功时返回：ESDHC_OK;其他返回值为错误
    586          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    587          u32 SDHC_ioctl(u32 cmd,void *param_ptr)
    588          {
   \                     SDHC_ioctl: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x000C             MOVS     R4,R1
    589              ESDHC_COMMAND_STRUCT    command; 
    590              u8 mem, io, mmc, ceata, mp, hc; //标志当前卡类型
    591              u32  i, val;
    592              u32  result = ESDHC_OK;
   \   00000008   0xF05F 0x0A00      MOVS     R10,#+0
    593              u32  *param32_ptr = param_ptr;
    594          #if PRINT
    595              uartPrintf("开始重新配置卡模式，发送卡模块命令\n");
    596          #endif
    597              
    598              switch (cmd) 
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD016             BEQ.N    ??SDHC_ioctl_0
   \   00000010   0xF0C0 0x8263      BCC.W    ??SDHC_ioctl_1
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xF000 0x8231      BEQ.W    ??SDHC_ioctl_2
   \   0000001A   0xF0C0 0x812A      BCC.W    ??SDHC_ioctl_3
   \   0000001E   0x2805             CMP      R0,#+5
   \   00000020   0xF000 0x814A      BEQ.W    ??SDHC_ioctl_4
   \   00000024   0xF0C0 0x812F      BCC.W    ??SDHC_ioctl_5
   \   00000028   0x2807             CMP      R0,#+7
   \   0000002A   0xF000 0x81EC      BEQ.W    ??SDHC_ioctl_6
   \   0000002E   0xF0C0 0x81CB      BCC.W    ??SDHC_ioctl_7
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xF000 0x81A2      BEQ.W    ??SDHC_ioctl_8
   \   00000038   0xF0C0 0x8194      BCC.W    ??SDHC_ioctl_9
   \   0000003C   0xE24D             B.N      ??SDHC_ioctl_1
    599              {
    600                  //初始化SD卡读写系统
    601                  case IO_IOCTL_ESDHC_INIT:        
    602                      result = SDHC_init (CORE_CLOCK_HZ, BAUD_RATE_HZ);
   \                     ??SDHC_ioctl_0: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable8_29  ;; 0x17d7840
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable8_30  ;; 0x5b8d800
   \   00000046   0x.... 0x....      BL       SDHC_init
   \   0000004A   0x4682             MOV      R10,R0
    603                      if (ESDHC_OK != result)
   \   0000004C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000050   0xF040 0x8245      BNE.W    ??SDHC_ioctl_10
    604                      {
    605                          break;
    606                      }
    607                      
    608                      mem = FALSE;
   \                     ??SDHC_ioctl_11: (+1)
   \   00000054   0x2400             MOVS     R4,#+0
    609                      io = FALSE;
   \   00000056   0x2500             MOVS     R5,#+0
    610                      mmc = FALSE;
   \   00000058   0x2600             MOVS     R6,#+0
    611                      ceata = FALSE;
   \   0000005A   0x2700             MOVS     R7,#+0
    612                      hc = FALSE;
   \   0000005C   0xF05F 0x0800      MOVS     R8,#+0
    613                      mp = FALSE;
   \   00000060   0xF05F 0x0900      MOVS     R9,#+0
    614          
    615                      //CMD0,使得SD卡进入空闲模式，复位SD卡
    616                      command.COMMAND = ESDHC_CMD0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF88D 0x0000      STRB     R0,[SP, #+0]
    617                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    618                      command.ARGUMENT = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x9001             STR      R0,[SP, #+4]
    619                      command.READ = FALSE;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF88D 0x0008      STRB     R0,[SP, #+8]
    620                      command.BLOCKS = 0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x9003             STR      R0,[SP, #+12]
    621                      if (SDHC_send_command (&command))
   \   0000007E   0xA800             ADD      R0,SP,#+0
   \   00000080   0x.... 0x....      BL       SDHC_send_command
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD002             BEQ.N    ??SDHC_ioctl_12
    622                      {
    623                          result = ESDHC_ERROR_INIT_FAILED;
   \   00000088   0xF05F 0x0A01      MOVS     R10,#+1
    624                          break;
   \   0000008C   0xE227             B.N      ??SDHC_ioctl_10
    625                      }
    626                      
    627                      for(i = 0;i < 2000000;i++)
   \                     ??SDHC_ioctl_12: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE000             B.N      ??SDHC_ioctl_13
   \                     ??SDHC_ioctl_14: (+1)
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \                     ??SDHC_ioctl_13: (+1)
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable8_31  ;; 0x1e8480
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD3FA             BCC.N    ??SDHC_ioctl_14
    628                      {
    629                      }
    630          
    631                      //CMD8
    632                      command.COMMAND = ESDHC_CMD8;
   \   0000009C   0x2008             MOVS     R0,#+8
   \   0000009E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    633                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF88D 0x0001      STRB     R0,[SP, #+1]
    634                      command.ARGUMENT = 0x000001AA;
   \   000000A8   0xF44F 0x70D5      MOV      R0,#+426
   \   000000AC   0x9001             STR      R0,[SP, #+4]
    635                      command.READ = FALSE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF88D 0x0008      STRB     R0,[SP, #+8]
    636                      command.BLOCKS = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x9003             STR      R0,[SP, #+12]
    637                      val = SDHC_send_command (&command);
   \   000000B8   0xA800             ADD      R0,SP,#+0
   \   000000BA   0x.... 0x....      BL       SDHC_send_command
   \   000000BE   0x4681             MOV      R9,R0
    638                      
    639                      if (val == 0)
   \   000000C0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000C4   0xD108             BNE.N    ??SDHC_ioctl_15
    640                      {
    641                          // SDHC卡
    642                          if (command.RESPONSE[0] != command.ARGUMENT)
   \   000000C6   0x9804             LDR      R0,[SP, #+16]
   \   000000C8   0x9901             LDR      R1,[SP, #+4]
   \   000000CA   0x4288             CMP      R0,R1
   \   000000CC   0xD002             BEQ.N    ??SDHC_ioctl_16
    643                          {
    644                              result = ESDHC_ERROR_INIT_FAILED;
   \   000000CE   0xF05F 0x0A01      MOVS     R10,#+1
    645                              break;
   \   000000D2   0xE204             B.N      ??SDHC_ioctl_10
    646                          }
    647                          hc = TRUE;
   \                     ??SDHC_ioctl_16: (+1)
   \   000000D4   0xF05F 0x0801      MOVS     R8,#+1
    648                      }
    649          
    650                      mp = TRUE;
   \                     ??SDHC_ioctl_15: (+1)
   \   000000D8   0xF05F 0x0901      MOVS     R9,#+1
    651                      
    652                      if (mp)
   \   000000DC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000E0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E4   0xF000 0x808C      BEQ.W    ??SDHC_ioctl_17
    653                      {
    654                          //CMD55，检查是否为MMC卡
    655                          command.COMMAND = ESDHC_CMD55;
   \   000000E8   0x2037             MOVS     R0,#+55
   \   000000EA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    656                          command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xF88D 0x0001      STRB     R0,[SP, #+1]
    657                          command.ARGUMENT = 0;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x9001             STR      R0,[SP, #+4]
    658                          command.READ = FALSE;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF88D 0x0008      STRB     R0,[SP, #+8]
    659                          command.BLOCKS = 0;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9003             STR      R0,[SP, #+12]
    660                          val = SDHC_send_command (&command);
   \   00000102   0xA800             ADD      R0,SP,#+0
   \   00000104   0x.... 0x....      BL       SDHC_send_command
   \   00000108   0x4681             MOV      R9,R0
    661                          if (val > 0)
   \   0000010A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000010E   0xD002             BEQ.N    ??SDHC_ioctl_18
    662                          {
    663                              result = ESDHC_ERROR_INIT_FAILED;
   \   00000110   0xF05F 0x0A01      MOVS     R10,#+1
    664                              break;
   \   00000114   0xE1E3             B.N      ??SDHC_ioctl_10
    665                          }
    666                          if (val < 0)
    667                          {
    668                              // MMC 或 CE-ATA
    669                              io = FALSE;
    670                              mem = FALSE;
    671                              hc = FALSE;
    672                              
    673                              //CMD1
    674                              command.COMMAND = ESDHC_CMD1;
    675                              command.TYPE = ESDHC_TYPE_NORMAL;
    676                              command.ARGUMENT = 0x40300000;
    677                              command.READ = FALSE;
    678                              command.BLOCKS = 0;
    679                              if (SDHC_send_command (&command))
    680                              {
    681                                  result = ESDHC_ERROR_INIT_FAILED;
    682                                  break;
    683                              }
    684                              if (0x20000000 == (command.RESPONSE[0] & 0x60000000))
    685                              {
    686                                  hc = TRUE;
    687                              }
    688                              mmc = TRUE;
    689          
    690                              //CMD39
    691                              command.COMMAND = ESDHC_CMD39;
    692                              command.TYPE = ESDHC_TYPE_NORMAL;
    693                              command.ARGUMENT = 0x0C00;
    694                              command.READ = FALSE;
    695                              command.BLOCKS = 0;
    696                              if (SDHC_send_command (&command))
    697                              {
    698                                  result = ESDHC_ERROR_INIT_FAILED;
    699                                  break;
    700                              }
    701                              if (0xCE == (command.RESPONSE[0] >> 8) & 0xFF)
    702                              {
    703                                  //CMD39
    704                                  command.COMMAND = ESDHC_CMD39;
    705                                  command.TYPE = ESDHC_TYPE_NORMAL;
    706                                  command.ARGUMENT = 0x0D00;
    707                                  command.READ = FALSE;
    708                                  command.BLOCKS = 0;
    709                                  if (SDHC_send_command (&command))
    710                                  {
    711                                      result = ESDHC_ERROR_INIT_FAILED;
    712                                      break;
    713                                  }
    714                                  if (0xAA == (command.RESPONSE[0] >> 8) & 0xFF)
    715                                  {
    716                                      mmc = FALSE;
    717                                      ceata = TRUE;
    718                                  }
    719                              }
    720                          }
    721                          else
    722                          {
    723                              //当为SD卡时
    724                              // ACMD41
    725                              command.COMMAND = ESDHC_ACMD41;
   \                     ??SDHC_ioctl_18: (+1)
   \   00000116   0x2069             MOVS     R0,#+105
   \   00000118   0xF88D 0x0000      STRB     R0,[SP, #+0]
    726                              command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    727                              command.ARGUMENT = 0;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x9001             STR      R0,[SP, #+4]
    728                              command.READ = FALSE;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xF88D 0x0008      STRB     R0,[SP, #+8]
    729                              command.BLOCKS = 0;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x9003             STR      R0,[SP, #+12]
    730                              if (SDHC_send_command (&command))
   \   00000130   0xA800             ADD      R0,SP,#+0
   \   00000132   0x.... 0x....      BL       SDHC_send_command
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD002             BEQ.N    ??SDHC_ioctl_19
    731                              {
    732                                  result = ESDHC_ERROR_INIT_FAILED;
   \   0000013A   0xF05F 0x0A01      MOVS     R10,#+1
    733                                  break;
   \   0000013E   0xE1CE             B.N      ??SDHC_ioctl_10
    734                              }
    735                              if (command.RESPONSE[0] & 0x300000)
   \                     ??SDHC_ioctl_19: (+1)
   \   00000140   0x9804             LDR      R0,[SP, #+16]
   \   00000142   0xF410 0x1F40      TST      R0,#0x300000
   \   00000146   0xD05B             BEQ.N    ??SDHC_ioctl_17
    736                              {
    737                                  val = 0;
   \   00000148   0xF05F 0x0900      MOVS     R9,#+0
    738                                  do 
    739                                  {
    740                                      for(i = 0;i < 500000;i++)
   \                     ??SDHC_ioctl_20: (+1)
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0xE000             B.N      ??SDHC_ioctl_21
   \                     ??SDHC_ioctl_22: (+1)
   \   00000150   0x1C40             ADDS     R0,R0,#+1
   \                     ??SDHC_ioctl_21: (+1)
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable8_32  ;; 0x7a120
   \   00000156   0x4288             CMP      R0,R1
   \   00000158   0xD3FA             BCC.N    ??SDHC_ioctl_22
    741                                      {
    742                                      }
    743                                      val++;
   \   0000015A   0xF119 0x0901      ADDS     R9,R9,#+1
    744                                      
    745                                      // CMD55 + ACMD41 - Send OCR 
    746                                      command.COMMAND = ESDHC_CMD55;
   \   0000015E   0x2037             MOVS     R0,#+55
   \   00000160   0xF88D 0x0000      STRB     R0,[SP, #+0]
    747                                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0xF88D 0x0001      STRB     R0,[SP, #+1]
    748                                      command.ARGUMENT = 0;
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x9001             STR      R0,[SP, #+4]
    749                                      command.READ = FALSE;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF88D 0x0008      STRB     R0,[SP, #+8]
    750                                      command.BLOCKS = 0;
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x9003             STR      R0,[SP, #+12]
    751                                      if (SDHC_send_command (&command))
   \   00000178   0xA800             ADD      R0,SP,#+0
   \   0000017A   0x.... 0x....      BL       SDHC_send_command
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD002             BEQ.N    ??SDHC_ioctl_23
    752                                      {
    753                                          result = ESDHC_ERROR_INIT_FAILED;
   \   00000182   0xF05F 0x0A01      MOVS     R10,#+1
    754                                          break;
   \   00000186   0xE024             B.N      ??SDHC_ioctl_24
    755                                      }
    756          
    757                                      command.COMMAND = ESDHC_ACMD41;
   \                     ??SDHC_ioctl_23: (+1)
   \   00000188   0x2069             MOVS     R0,#+105
   \   0000018A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    758                                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0xF88D 0x0001      STRB     R0,[SP, #+1]
    759                                      if (hc)
   \   00000194   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000198   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000019C   0xD003             BEQ.N    ??SDHC_ioctl_25
    760                                      {
    761                                          command.ARGUMENT = 0x40300000;
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable8_33  ;; 0x40300000
   \   000001A2   0x9001             STR      R0,[SP, #+4]
   \   000001A4   0xE002             B.N      ??SDHC_ioctl_26
    762                                      }
    763                                      else
    764                                      {
    765                                          command.ARGUMENT = 0x00300000;
   \                     ??SDHC_ioctl_25: (+1)
   \   000001A6   0xF45F 0x1040      MOVS     R0,#+3145728
   \   000001AA   0x9001             STR      R0,[SP, #+4]
    766                                      }
    767                                      command.READ = FALSE;
   \                     ??SDHC_ioctl_26: (+1)
   \   000001AC   0x2000             MOVS     R0,#+0
   \   000001AE   0xF88D 0x0008      STRB     R0,[SP, #+8]
    768                                      command.BLOCKS = 0;
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x9003             STR      R0,[SP, #+12]
    769                                      if (SDHC_send_command (&command))
   \   000001B6   0xA800             ADD      R0,SP,#+0
   \   000001B8   0x.... 0x....      BL       SDHC_send_command
   \   000001BC   0x2800             CMP      R0,#+0
   \   000001BE   0xD002             BEQ.N    ??SDHC_ioctl_27
    770                                      {
    771                                          result = ESDHC_ERROR_INIT_FAILED;
   \   000001C0   0xF05F 0x0A01      MOVS     R10,#+1
    772                                          break;
   \   000001C4   0xE005             B.N      ??SDHC_ioctl_24
    773                                      }
    774                                  } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < 10));
   \                     ??SDHC_ioctl_27: (+1)
   \   000001C6   0x9804             LDR      R0,[SP, #+16]
   \   000001C8   0x2800             CMP      R0,#+0
   \   000001CA   0xD402             BMI.N    ??SDHC_ioctl_24
   \   000001CC   0xF1B9 0x0F0A      CMP      R9,#+10
   \   000001D0   0xD3BC             BCC.N    ??SDHC_ioctl_20
    775                                  if (ESDHC_OK != result)
   \                     ??SDHC_ioctl_24: (+1)
   \   000001D2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001D6   0xF040 0x8182      BNE.W    ??SDHC_ioctl_10
    776                                  {
    777                                      break;
    778                                  }
    779                                  if (val >= 10)
   \                     ??SDHC_ioctl_28: (+1)
   \   000001DA   0xF1B9 0x0F0A      CMP      R9,#+10
   \   000001DE   0xD302             BCC.N    ??SDHC_ioctl_29
    780                                  {
    781                                      hc = FALSE;
   \   000001E0   0xF05F 0x0800      MOVS     R8,#+0
   \   000001E4   0xE00C             B.N      ??SDHC_ioctl_17
    782                                  }
    783                                  else
    784                                  {
    785                                      mem = TRUE;
   \                     ??SDHC_ioctl_29: (+1)
   \   000001E6   0x2401             MOVS     R4,#+1
    786                                      if (hc)
   \   000001E8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001EC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001F0   0xD006             BEQ.N    ??SDHC_ioctl_17
    787                                      {
    788                                          hc = FALSE;
   \   000001F2   0xF05F 0x0800      MOVS     R8,#+0
    789                                          if (command.RESPONSE[0] & 0x40000000)
   \   000001F6   0x9804             LDR      R0,[SP, #+16]
   \   000001F8   0x0040             LSLS     R0,R0,#+1
   \   000001FA   0xD501             BPL.N    ??SDHC_ioctl_17
    790                                          {
    791                                              hc = TRUE;
   \   000001FC   0xF05F 0x0801      MOVS     R8,#+1
    792                                          }
    793                                      }
    794                                  }
    795                              }
    796                          }
    797                      }
    798                      
    799                      
    800                      if (mmc)
   \                     ??SDHC_ioctl_17: (+1)
   \   00000200   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000202   0x2E00             CMP      R6,#+0
   \   00000204   0xD003             BEQ.N    ??SDHC_ioctl_30
    801                      {
    802                          SDHC_Card.CARD_TYPE = ESDHC_CARD_MMC;
   \   00000206   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   0000020A   0x2107             MOVS     R1,#+7
   \   0000020C   0x7001             STRB     R1,[R0, #+0]
    803                      }
    804                      if (ceata)
   \                     ??SDHC_ioctl_30: (+1)
   \   0000020E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000210   0x2F00             CMP      R7,#+0
   \   00000212   0xD003             BEQ.N    ??SDHC_ioctl_31
    805                      {
    806                          SDHC_Card.CARD_TYPE = ESDHC_CARD_CEATA;
   \   00000214   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   00000218   0x2108             MOVS     R1,#+8
   \   0000021A   0x7001             STRB     R1,[R0, #+0]
    807                      }
    808                      if (io)
   \                     ??SDHC_ioctl_31: (+1)
   \   0000021C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000021E   0x2D00             CMP      R5,#+0
   \   00000220   0xD003             BEQ.N    ??SDHC_ioctl_32
    809                      {
    810                          SDHC_Card.CARD_TYPE = ESDHC_CARD_SDIO;
   \   00000222   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   00000226   0x2104             MOVS     R1,#+4
   \   00000228   0x7001             STRB     R1,[R0, #+0]
    811                      }
    812                      if (mem)
   \                     ??SDHC_ioctl_32: (+1)
   \   0000022A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000022C   0x2C00             CMP      R4,#+0
   \   0000022E   0xD00C             BEQ.N    ??SDHC_ioctl_33
    813                      {
    814                          SDHC_Card.CARD_TYPE = ESDHC_CARD_SD;
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   00000234   0x2102             MOVS     R1,#+2
   \   00000236   0x7001             STRB     R1,[R0, #+0]
    815                          if (hc)
   \   00000238   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000023C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000240   0xD003             BEQ.N    ??SDHC_ioctl_33
    816                          {
    817                              SDHC_Card.CARD_TYPE = ESDHC_CARD_SDHC;
   \   00000242   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   00000246   0x2103             MOVS     R1,#+3
   \   00000248   0x7001             STRB     R1,[R0, #+0]
    818                          }
    819                      }
    820                      if (io && mem)
   \                     ??SDHC_ioctl_33: (+1)
   \   0000024A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000024C   0x2D00             CMP      R5,#+0
   \   0000024E   0xD00F             BEQ.N    ??SDHC_ioctl_34
   \   00000250   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000252   0x2C00             CMP      R4,#+0
   \   00000254   0xD00C             BEQ.N    ??SDHC_ioctl_34
    821                      {
    822                          SDHC_Card.CARD_TYPE = ESDHC_CARD_SDCOMBO;
   \   00000256   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   0000025A   0x2105             MOVS     R1,#+5
   \   0000025C   0x7001             STRB     R1,[R0, #+0]
    823                          if (hc)
   \   0000025E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000262   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000266   0xD003             BEQ.N    ??SDHC_ioctl_34
    824                          {
    825                              SDHC_Card.CARD_TYPE = ESDHC_CARD_SDHCCOMBO;
   \   00000268   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   0000026C   0x2106             MOVS     R1,#+6
   \   0000026E   0x7001             STRB     R1,[R0, #+0]
    826                          }
    827                      }
    828          
    829                      /*
    830                      //清除引脚复用寄存器
    831                      PORTE_PCR(0) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D1  
    832                      PORTE_PCR(1) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D0  
    833                      PORTE_PCR(2) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          // ESDHC.CLK 
    834                      PORTE_PCR(3) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.CMD 
    835                      PORTE_PCR(4) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D3  
    836                      PORTE_PCR(5) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D2  
    837          
    838                      //设置SDHC模块的波特率
    839                      SDHC_set_baudrate (CORE_CLOCK_HZ, BAUD_RATE_HZ);
    840          
    841                      //设置复用引脚功能为SDHC
    842                      PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D1  
    843                      PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D0  
    844                      PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          // ESDHC.CLK 
    845                      PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.CMD 
    846                      PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D3  
    847                      PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D2  
    848          
    849                      //使能SDHC模块的时钟
    850                      SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
    851                      */
    852                      break;
   \                     ??SDHC_ioctl_34: (+1)
   \   00000270   0xE135             B.N      ??SDHC_ioctl_10
    853                  //向卡发送命令
    854                  case IO_IOCTL_ESDHC_SEND_COMMAND:
    855          #if PRINT
    856                    uartPrintf("发送命令：IO_IOCTL_ESDHC_SEND_COMMAND\n");
    857          #endif
    858                      val = SDHC_send_command ((ESDHC_COMMAND_STRUCT_PTR)param32_ptr);
   \                     ??SDHC_ioctl_3: (+1)
   \   00000272   0x0020             MOVS     R0,R4
   \   00000274   0x.... 0x....      BL       SDHC_send_command
   \   00000278   0x4681             MOV      R9,R0
    859                      if (val > 0)
   \   0000027A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000027E   0xD001             BEQ.N    ??SDHC_ioctl_35
    860                      {
    861                          result = ESDHC_ERROR_COMMAND_FAILED;
   \   00000280   0xF05F 0x0A02      MOVS     R10,#+2
    862                      }
    863                      if (val < 0)
    864                      {
    865                          result = ESDHC_ERROR_COMMAND_TIMEOUT;
    866                      }
    867                      break;
   \                     ??SDHC_ioctl_35: (+1)
   \   00000284   0xE12B             B.N      ??SDHC_ioctl_10
    868                  //获取当前通信波特率状态
    869                  case IO_IOCTL_ESDHC_GET_BAUDRATE:
    870                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_5: (+1)
   \   00000286   0x2C00             CMP      R4,#+0
   \   00000288   0xD102             BNE.N    ??SDHC_ioctl_36
    871                      {
    872                          result = IO_ERROR_INVALID_PARAMETER;
   \   0000028A   0xF05F 0x0A0C      MOVS     R10,#+12
   \   0000028E   0xE012             B.N      ??SDHC_ioctl_37
    873                      } 
    874                      else 
    875                      {
    876                          //获取当前设置的波特率
    877                          val = ((SDHC_SYSCTL & SDHC_SYSCTL_SDCLKFS_MASK) >> SDHC_SYSCTL_SDCLKFS_SHIFT) << 1;
   \                     ??SDHC_ioctl_36: (+1)
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x400b102c
   \   00000294   0x6800             LDR      R0,[R0, #+0]
   \   00000296   0x09C0             LSRS     R0,R0,#+7
   \   00000298   0xF410 0x79FF      ANDS     R9,R0,#0x1FE
    878                          val *= ((SDHC_SYSCTL & SDHC_SYSCTL_DVS_MASK) >> SDHC_SYSCTL_DVS_SHIFT) + 1;
   \   0000029C   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x400b102c
   \   000002A0   0x6800             LDR      R0,[R0, #+0]
   \   000002A2   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   000002A6   0x1C40             ADDS     R0,R0,#+1
   \   000002A8   0xFB00 0xF909      MUL      R9,R0,R9
    879                          *param32_ptr = (u32)(CORE_CLOCK_HZ / val);
   \   000002AC   0x.... 0x....      LDR.W    R0,??DataTable8_30  ;; 0x5b8d800
   \   000002B0   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   000002B4   0x6020             STR      R0,[R4, #+0]
    880                      }
    881                      break;
   \                     ??SDHC_ioctl_37: (+1)
   \   000002B6   0xE112             B.N      ??SDHC_ioctl_10
    882                  //设定当前通信波特率状态
    883                  case IO_IOCTL_ESDHC_SET_BAUDRATE:
    884                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_4: (+1)
   \   000002B8   0x2C00             CMP      R4,#+0
   \   000002BA   0xD102             BNE.N    ??SDHC_ioctl_38
    885                      {
    886                          result = IO_ERROR_INVALID_PARAMETER;
   \   000002BC   0xF05F 0x0A0C      MOVS     R10,#+12
   \   000002C0   0xE04F             B.N      ??SDHC_ioctl_39
    887                      } 
    888                      else if (0 == (*param32_ptr)) 
   \                     ??SDHC_ioctl_38: (+1)
   \   000002C2   0x6820             LDR      R0,[R4, #+0]
   \   000002C4   0x2800             CMP      R0,#+0
   \   000002C6   0xD102             BNE.N    ??SDHC_ioctl_40
    889                      {
    890                          result = IO_ERROR_INVALID_PARAMETER;
   \   000002C8   0xF05F 0x0A0C      MOVS     R10,#+12
   \   000002CC   0xE049             B.N      ??SDHC_ioctl_39
    891                      } 
    892                      else 
    893                      {
    894                          if (! SDHC_is_running())
   \                     ??SDHC_ioctl_40: (+1)
   \   000002CE   0x.... 0x....      BL       SDHC_is_running
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD143             BNE.N    ??SDHC_ioctl_41
    895                          {
    896                              //清除引脚复用寄存器
    897                              PORTE_PCR(0) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D1  
   \   000002D6   0x.... 0x....      LDR.W    R0,??DataTable8_16  ;; 0x4004d000
   \   000002DA   0x2100             MOVS     R1,#+0
   \   000002DC   0x6001             STR      R1,[R0, #+0]
    898                              PORTE_PCR(1) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D0  
   \   000002DE   0x.... 0x....      LDR.W    R0,??DataTable8_17  ;; 0x4004d004
   \   000002E2   0x2100             MOVS     R1,#+0
   \   000002E4   0x6001             STR      R1,[R0, #+0]
    899                              PORTE_PCR(2) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          // ESDHC.CLK 
   \   000002E6   0x.... 0x....      LDR.W    R0,??DataTable8_18  ;; 0x4004d008
   \   000002EA   0x2100             MOVS     R1,#+0
   \   000002EC   0x6001             STR      R1,[R0, #+0]
    900                              PORTE_PCR(3) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.CMD 
   \   000002EE   0x.... 0x....      LDR.W    R0,??DataTable8_19  ;; 0x4004d00c
   \   000002F2   0x2100             MOVS     R1,#+0
   \   000002F4   0x6001             STR      R1,[R0, #+0]
    901                              PORTE_PCR(4) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D3  
   \   000002F6   0x.... 0x....      LDR.W    R0,??DataTable8_20  ;; 0x4004d010
   \   000002FA   0x2100             MOVS     R1,#+0
   \   000002FC   0x6001             STR      R1,[R0, #+0]
    902                              PORTE_PCR(5) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D2  
   \   000002FE   0x.... 0x....      LDR.W    R0,??DataTable8_21  ;; 0x4004d014
   \   00000302   0x2100             MOVS     R1,#+0
   \   00000304   0x6001             STR      R1,[R0, #+0]
    903          
    904                              //设置SDHC模块的波特率
    905                              SDHC_set_baudrate (CORE_CLOCK_HZ, *param32_ptr);
   \   00000306   0x6821             LDR      R1,[R4, #+0]
   \   00000308   0x.... 0x....      LDR.W    R0,??DataTable8_30  ;; 0x5b8d800
   \   0000030C   0x.... 0x....      BL       SDHC_set_baudrate
    906          
    907                              //设置复用引脚功能为SDHC
    908                              PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D1  
   \   00000310   0x.... 0x....      LDR.W    R0,??DataTable8_16  ;; 0x4004d000
   \   00000314   0xF240 0x4143      MOVW     R1,#+1091
   \   00000318   0x6001             STR      R1,[R0, #+0]
    909                              PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D0  
   \   0000031A   0x.... 0x....      LDR.W    R0,??DataTable8_17  ;; 0x4004d004
   \   0000031E   0xF240 0x4143      MOVW     R1,#+1091
   \   00000322   0x6001             STR      R1,[R0, #+0]
    910                              PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          // ESDHC.CLK 
   \   00000324   0x.... 0x....      LDR.W    R0,??DataTable8_18  ;; 0x4004d008
   \   00000328   0xF44F 0x6188      MOV      R1,#+1088
   \   0000032C   0x6001             STR      R1,[R0, #+0]
    911                              PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.CMD 
   \   0000032E   0x.... 0x....      LDR.W    R0,??DataTable8_19  ;; 0x4004d00c
   \   00000332   0xF240 0x4143      MOVW     R1,#+1091
   \   00000336   0x6001             STR      R1,[R0, #+0]
    912                              PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D3  
   \   00000338   0x.... 0x....      LDR.W    R0,??DataTable8_20  ;; 0x4004d010
   \   0000033C   0xF240 0x4143      MOVW     R1,#+1091
   \   00000340   0x6001             STR      R1,[R0, #+0]
    913                              PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    // ESDHC.D2  
   \   00000342   0x.... 0x....      LDR.W    R0,??DataTable8_21  ;; 0x4004d014
   \   00000346   0xF240 0x4143      MOVW     R1,#+1091
   \   0000034A   0x6001             STR      R1,[R0, #+0]
    914          
    915                              //使能SDHC模块的时钟
    916                              SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   0000034C   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x40048030
   \   00000350   0x6800             LDR      R0,[R0, #+0]
   \   00000352   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000356   0x.... 0x....      LDR.W    R1,??DataTable8_8  ;; 0x40048030
   \   0000035A   0x6008             STR      R0,[R1, #+0]
   \   0000035C   0xE001             B.N      ??SDHC_ioctl_39
    917                          }
    918                          else
    919                          {
    920                              result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_41: (+1)
   \   0000035E   0xF05F 0x0A0A      MOVS     R10,#+10
    921                          }
    922                      }
    923                      break;
   \                     ??SDHC_ioctl_39: (+1)
   \   00000362   0xE0BC             B.N      ??SDHC_ioctl_10
    924                  //获取块长度
    925                  case IO_IOCTL_ESDHC_GET_BLOCK_SIZE:
    926                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_9: (+1)
   \   00000364   0x2C00             CMP      R4,#+0
   \   00000366   0xD102             BNE.N    ??SDHC_ioctl_42
    927                      {
    928                          result = IO_ERROR_INVALID_PARAMETER;
   \   00000368   0xF05F 0x0A0C      MOVS     R10,#+12
   \   0000036C   0xE005             B.N      ??SDHC_ioctl_43
    929                      } 
    930                      else 
    931                      {
    932                          //获取SDHC模块设置的块的大小
    933                          *param32_ptr = (SDHC_BLKATTR & SDHC_BLKATTR_BLKSIZE_MASK) >> SDHC_BLKATTR_BLKSIZE_SHIFT;
   \                     ??SDHC_ioctl_42: (+1)
   \   0000036E   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x400b1004
   \   00000372   0x6800             LDR      R0,[R0, #+0]
   \   00000374   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   00000376   0x0CC0             LSRS     R0,R0,#+19
   \   00000378   0x6020             STR      R0,[R4, #+0]
    934                      }       
    935                      break;
   \                     ??SDHC_ioctl_43: (+1)
   \   0000037A   0xE0B0             B.N      ??SDHC_ioctl_10
    936                  //设定块长度
    937                  case IO_IOCTL_ESDHC_SET_BLOCK_SIZE:
    938                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_8: (+1)
   \   0000037C   0x2C00             CMP      R4,#+0
   \   0000037E   0xD102             BNE.N    ??SDHC_ioctl_44
    939                      {
    940                          result = IO_ERROR_INVALID_PARAMETER;
   \   00000380   0xF05F 0x0A0C      MOVS     R10,#+12
   \   00000384   0xE01F             B.N      ??SDHC_ioctl_45
    941                      } 
    942                      else 
    943                      {
    944                          //设置SDHC模块处理的块的大小
    945                          if (! SDHC_is_running())
   \                     ??SDHC_ioctl_44: (+1)
   \   00000386   0x.... 0x....      BL       SDHC_is_running
   \   0000038A   0x2800             CMP      R0,#+0
   \   0000038C   0xD119             BNE.N    ??SDHC_ioctl_46
    946                          {
    947                              if (*param32_ptr > 0x0FFF)
   \   0000038E   0x6820             LDR      R0,[R4, #+0]
   \   00000390   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000394   0xD302             BCC.N    ??SDHC_ioctl_47
    948                              {
    949                                  result = IO_ERROR_INVALID_PARAMETER;
   \   00000396   0xF05F 0x0A0C      MOVS     R10,#+12
   \   0000039A   0xE014             B.N      ??SDHC_ioctl_45
    950                              }
    951                              else
    952                              {
    953                                  SDHC_BLKATTR &= (~ SDHC_BLKATTR_BLKSIZE_MASK); 
   \                     ??SDHC_ioctl_47: (+1)
   \   0000039C   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x400b1004
   \   000003A0   0x6800             LDR      R0,[R0, #+0]
   \   000003A2   0x0B40             LSRS     R0,R0,#+13
   \   000003A4   0x0340             LSLS     R0,R0,#+13
   \   000003A6   0x.... 0x....      LDR.W    R1,??DataTable8_12  ;; 0x400b1004
   \   000003AA   0x6008             STR      R0,[R1, #+0]
    954                                  SDHC_BLKATTR |= SDHC_BLKATTR_BLKSIZE(*param32_ptr);
   \   000003AC   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x400b1004
   \   000003B0   0x6800             LDR      R0,[R0, #+0]
   \   000003B2   0x6821             LDR      R1,[R4, #+0]
   \   000003B4   0x04C9             LSLS     R1,R1,#+19       ;; ZeroExtS R1,R1,#+19,#+19
   \   000003B6   0x0CC9             LSRS     R1,R1,#+19
   \   000003B8   0x4308             ORRS     R0,R1,R0
   \   000003BA   0x.... 0x....      LDR.W    R1,??DataTable8_12  ;; 0x400b1004
   \   000003BE   0x6008             STR      R0,[R1, #+0]
   \   000003C0   0xE001             B.N      ??SDHC_ioctl_45
    955                              }
    956                          }
    957                          else
    958                          {
    959                              result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_46: (+1)
   \   000003C2   0xF05F 0x0A0A      MOVS     R10,#+10
    960                          }
    961                      }       
    962                      break;
   \                     ??SDHC_ioctl_45: (+1)
   \   000003C6   0xE08A             B.N      ??SDHC_ioctl_10
    963                  //获取卡通信总线位宽
    964                  case IO_IOCTL_ESDHC_GET_BUS_WIDTH:
    965                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_7: (+1)
   \   000003C8   0x2C00             CMP      R4,#+0
   \   000003CA   0xD102             BNE.N    ??SDHC_ioctl_48
    966                      {
    967                          result = IO_ERROR_INVALID_PARAMETER;
   \   000003CC   0xF05F 0x0A0C      MOVS     R10,#+12
   \   000003D0   0xE018             B.N      ??SDHC_ioctl_49
    968                      } 
    969                      else 
    970                      {
    971                          //获取当前配置的SDHC模块的总线宽度
    972                          val = (SDHC_PROCTL & SDHC_PROCTL_DTW_MASK) >> SDHC_PROCTL_DTW_SHIFT;
   \                     ??SDHC_ioctl_48: (+1)
   \   000003D2   0x.... 0x....      LDR.W    R0,??DataTable8_13  ;; 0x400b1028
   \   000003D6   0x6800             LDR      R0,[R0, #+0]
   \   000003D8   0xF3C0 0x0941      UBFX     R9,R0,#+1,#+2
    973                          if (ESDHC_PROCTL_DTW_1BIT == val)
   \   000003DC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000003E0   0xD102             BNE.N    ??SDHC_ioctl_50
    974                          {
    975                              *param32_ptr = ESDHC_BUS_WIDTH_1BIT;
   \   000003E2   0x2000             MOVS     R0,#+0
   \   000003E4   0x6020             STR      R0,[R4, #+0]
   \   000003E6   0xE00D             B.N      ??SDHC_ioctl_49
    976                          }
    977                          else if (ESDHC_PROCTL_DTW_4BIT == val)
   \                     ??SDHC_ioctl_50: (+1)
   \   000003E8   0xF1B9 0x0F01      CMP      R9,#+1
   \   000003EC   0xD102             BNE.N    ??SDHC_ioctl_51
    978                          {
    979                              *param32_ptr = ESDHC_BUS_WIDTH_4BIT;
   \   000003EE   0x2001             MOVS     R0,#+1
   \   000003F0   0x6020             STR      R0,[R4, #+0]
   \   000003F2   0xE007             B.N      ??SDHC_ioctl_49
    980                          }
    981                          else if (ESDHC_PROCTL_DTW_8BIT == val)
   \                     ??SDHC_ioctl_51: (+1)
   \   000003F4   0xF1B9 0x0F10      CMP      R9,#+16
   \   000003F8   0xD102             BNE.N    ??SDHC_ioctl_52
    982                          {
    983                              *param32_ptr = ESDHC_BUS_WIDTH_8BIT;
   \   000003FA   0x2002             MOVS     R0,#+2
   \   000003FC   0x6020             STR      R0,[R4, #+0]
   \   000003FE   0xE001             B.N      ??SDHC_ioctl_49
    984                          }
    985                          else
    986                          {
    987                              result = ESDHC_ERROR_INVALID_BUS_WIDTH; 
   \                     ??SDHC_ioctl_52: (+1)
   \   00000400   0xF05F 0x0A05      MOVS     R10,#+5
    988                          }
    989                      }       
    990                      break;
   \                     ??SDHC_ioctl_49: (+1)
   \   00000404   0xE06B             B.N      ??SDHC_ioctl_10
    991                  //设定卡通信总线位宽
    992                  case IO_IOCTL_ESDHC_SET_BUS_WIDTH:
    993                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_6: (+1)
   \   00000406   0x2C00             CMP      R4,#+0
   \   00000408   0xD102             BNE.N    ??SDHC_ioctl_53
    994                      {
    995                          result = IO_ERROR_INVALID_PARAMETER;
   \   0000040A   0xF05F 0x0A0C      MOVS     R10,#+12
   \   0000040E   0xE034             B.N      ??SDHC_ioctl_54
    996                      } 
    997                      else 
    998                      {
    999                          //设置SDHC模块的总线宽度
   1000                          if (! SDHC_is_running())
   \                     ??SDHC_ioctl_53: (+1)
   \   00000410   0x.... 0x....      BL       SDHC_is_running
   \   00000414   0x2800             CMP      R0,#+0
   \   00000416   0xD12E             BNE.N    ??SDHC_ioctl_55
   1001                          {
   1002                              if (ESDHC_BUS_WIDTH_1BIT == *param32_ptr)
   \   00000418   0x6820             LDR      R0,[R4, #+0]
   \   0000041A   0x2800             CMP      R0,#+0
   \   0000041C   0xD10A             BNE.N    ??SDHC_ioctl_56
   1003                              {
   1004                                  SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   0000041E   0x....             LDR.N    R0,??DataTable8_13  ;; 0x400b1028
   \   00000420   0x6800             LDR      R0,[R0, #+0]
   \   00000422   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000426   0x....             LDR.N    R1,??DataTable8_13  ;; 0x400b1028
   \   00000428   0x6008             STR      R0,[R1, #+0]
   1005                                  SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_1BIT);
   \   0000042A   0x....             LDR.N    R0,??DataTable8_13  ;; 0x400b1028
   \   0000042C   0x....             LDR.N    R1,??DataTable8_13  ;; 0x400b1028
   \   0000042E   0x6809             LDR      R1,[R1, #+0]
   \   00000430   0x6001             STR      R1,[R0, #+0]
   \   00000432   0xE022             B.N      ??SDHC_ioctl_54
   1006                              }
   1007                              else if (ESDHC_BUS_WIDTH_4BIT == *param32_ptr)
   \                     ??SDHC_ioctl_56: (+1)
   \   00000434   0x6820             LDR      R0,[R4, #+0]
   \   00000436   0x2801             CMP      R0,#+1
   \   00000438   0xD10C             BNE.N    ??SDHC_ioctl_57
   1008                              {
   1009                                  SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   0000043A   0x....             LDR.N    R0,??DataTable8_13  ;; 0x400b1028
   \   0000043C   0x6800             LDR      R0,[R0, #+0]
   \   0000043E   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000442   0x....             LDR.N    R1,??DataTable8_13  ;; 0x400b1028
   \   00000444   0x6008             STR      R0,[R1, #+0]
   1010                                  SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_4BIT);
   \   00000446   0x....             LDR.N    R0,??DataTable8_13  ;; 0x400b1028
   \   00000448   0x6800             LDR      R0,[R0, #+0]
   \   0000044A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000044E   0x....             LDR.N    R1,??DataTable8_13  ;; 0x400b1028
   \   00000450   0x6008             STR      R0,[R1, #+0]
   \   00000452   0xE012             B.N      ??SDHC_ioctl_54
   1011                              }
   1012                              else if (ESDHC_BUS_WIDTH_8BIT == *param32_ptr)
   \                     ??SDHC_ioctl_57: (+1)
   \   00000454   0x6820             LDR      R0,[R4, #+0]
   \   00000456   0x2802             CMP      R0,#+2
   \   00000458   0xD10A             BNE.N    ??SDHC_ioctl_58
   1013                              {
   1014                                  SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   0000045A   0x....             LDR.N    R0,??DataTable8_13  ;; 0x400b1028
   \   0000045C   0x6800             LDR      R0,[R0, #+0]
   \   0000045E   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000462   0x....             LDR.N    R1,??DataTable8_13  ;; 0x400b1028
   \   00000464   0x6008             STR      R0,[R1, #+0]
   1015                                  SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_8BIT);
   \   00000466   0x....             LDR.N    R0,??DataTable8_13  ;; 0x400b1028
   \   00000468   0x....             LDR.N    R1,??DataTable8_13  ;; 0x400b1028
   \   0000046A   0x6809             LDR      R1,[R1, #+0]
   \   0000046C   0x6001             STR      R1,[R0, #+0]
   \   0000046E   0xE004             B.N      ??SDHC_ioctl_54
   1016                              }
   1017                              else
   1018                              {
   1019                                  result = ESDHC_ERROR_INVALID_BUS_WIDTH; 
   \                     ??SDHC_ioctl_58: (+1)
   \   00000470   0xF05F 0x0A05      MOVS     R10,#+5
   \   00000474   0xE001             B.N      ??SDHC_ioctl_54
   1020                              }
   1021                          }
   1022                          else
   1023                          {
   1024                              result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_55: (+1)
   \   00000476   0xF05F 0x0A0A      MOVS     R10,#+10
   1025                          }
   1026                      }       
   1027                      break;
   \                     ??SDHC_ioctl_54: (+1)
   \   0000047A   0xE030             B.N      ??SDHC_ioctl_10
   1028                  //获取卡当前状态
   1029                  case IO_IOCTL_ESDHC_GET_CARD:
   1030                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_2: (+1)
   \   0000047C   0x2C00             CMP      R4,#+0
   \   0000047E   0xD102             BNE.N    ??SDHC_ioctl_59
   1031                      {
   1032                          result = IO_ERROR_INVALID_PARAMETER;
   \   00000480   0xF05F 0x0A0C      MOVS     R10,#+12
   \   00000484   0xE028             B.N      ??SDHC_ioctl_60
   1033                      } 
   1034                      else 
   1035                      {
   1036                          //等待80个时钟
   1037                          SDHC_SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \                     ??SDHC_ioctl_59: (+1)
   \   00000486   0x....             LDR.N    R0,??DataTable8_9  ;; 0x400b102c
   \   00000488   0x6800             LDR      R0,[R0, #+0]
   \   0000048A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000048E   0x....             LDR.N    R1,??DataTable8_9  ;; 0x400b102c
   \   00000490   0x6008             STR      R0,[R1, #+0]
   1038                          while (SDHC_SYSCTL & SDHC_SYSCTL_INITA_MASK){};
   \                     ??SDHC_ioctl_61: (+1)
   \   00000492   0x....             LDR.N    R0,??DataTable8_9  ;; 0x400b102c
   \   00000494   0x6800             LDR      R0,[R0, #+0]
   \   00000496   0x0100             LSLS     R0,R0,#+4
   \   00000498   0xD4FB             BMI.N    ??SDHC_ioctl_61
   1039                              
   1040                          //读取SD卡返回的状态
   1041                          if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \   0000049A   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   0000049C   0x6800             LDR      R0,[R0, #+0]
   \   0000049E   0x0600             LSLS     R0,R0,#+24
   \   000004A0   0xD508             BPL.N    ??SDHC_ioctl_62
   1042                          {
   1043                              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \   000004A2   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   000004A4   0x6800             LDR      R0,[R0, #+0]
   \   000004A6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000004AA   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   000004AC   0x6008             STR      R0,[R1, #+0]
   1044                              SDHC_Card.CARD_TYPE = ESDHC_CARD_NONE;
   \   000004AE   0x....             LDR.N    R0,??DataTable8_7
   \   000004B0   0x2100             MOVS     R1,#+0
   \   000004B2   0x7001             STRB     R1,[R0, #+0]
   1045                          }
   1046                          if (SDHC_PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \                     ??SDHC_ioctl_62: (+1)
   \   000004B4   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400b1024
   \   000004B6   0x6800             LDR      R0,[R0, #+0]
   \   000004B8   0x03C0             LSLS     R0,R0,#+15
   \   000004BA   0xD507             BPL.N    ??SDHC_ioctl_63
   1047                          {
   1048                              if (ESDHC_CARD_NONE == SDHC_Card.CARD_TYPE)
   \   000004BC   0x....             LDR.N    R0,??DataTable8_7
   \   000004BE   0x7800             LDRB     R0,[R0, #+0]
   \   000004C0   0x2800             CMP      R0,#+0
   \   000004C2   0xD106             BNE.N    ??SDHC_ioctl_64
   1049                              {
   1050                              	SDHC_Card.CARD_TYPE = ESDHC_CARD_UNKNOWN;
   \   000004C4   0x....             LDR.N    R0,??DataTable8_7
   \   000004C6   0x2101             MOVS     R1,#+1
   \   000004C8   0x7001             STRB     R1,[R0, #+0]
   \   000004CA   0xE002             B.N      ??SDHC_ioctl_64
   1051                              }
   1052                          }
   1053                          else
   1054                          {
   1055                          	SDHC_Card.CARD_TYPE = ESDHC_CARD_NONE;
   \                     ??SDHC_ioctl_63: (+1)
   \   000004CC   0x....             LDR.N    R0,??DataTable8_7
   \   000004CE   0x2100             MOVS     R1,#+0
   \   000004D0   0x7001             STRB     R1,[R0, #+0]
   1056                          }
   1057                          *param32_ptr = SDHC_Card.CARD_TYPE;
   \                     ??SDHC_ioctl_64: (+1)
   \   000004D2   0x....             LDR.N    R0,??DataTable8_7
   \   000004D4   0x7800             LDRB     R0,[R0, #+0]
   \   000004D6   0x6020             STR      R0,[R4, #+0]
   1058                      }
   1059                      break;
   \                     ??SDHC_ioctl_60: (+1)
   \   000004D8   0xE001             B.N      ??SDHC_ioctl_10
   1060                  default:
   1061                      result = IO_ERROR_INVALID_IOCTL_CMD;
   \                     ??SDHC_ioctl_1: (+1)
   \   000004DA   0xF05F 0x0A09      MOVS     R10,#+9
   1062                      break;
   1063              }
   1064              return result;
   \                     ??SDHC_ioctl_10: (+1)
   \   000004DE   0x4650             MOV      R0,R10
   \   000004E0   0xB008             ADD      SP,SP,#+32
   \   000004E2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1065          }
   1066          
   1067          
   1068          //=========================================================================
   1069          //函数名称：SDHC_set_baudrate                                                        
   1070          //功能概要：设置SDHC模块的时钟。                                                
   1071          //参数说明：clock:系统时钟                                               
   1072          //         baudrate：波特率                                 
   1073          //函数返回：无                                                               
   1074          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
   1075          void SDHC_set_baudrate(u32 clock,u32 baudrate)
   1076          {
   \                     SDHC_set_baudrate: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1077              u32 i, pres, div, min, minpres = 0x80, mindiv = 0x0F;
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x230F             MOVS     R3,#+15
   1078              u32  val;
   1079          
   1080              //找到相近的分频因子
   1081              min = (u32)-1;
   \   00000006   0xF05F 0x36FF      MOVS     R6,#-1
   1082              for (pres = 2; pres <= 256; pres <<= 1) 
   \   0000000A   0x2402             MOVS     R4,#+2
   \   0000000C   0xE00C             B.N      ??SDHC_set_baudrate_0
   1083              {
   1084                  for (div = 1; div <= 16; div++) 
   1085                  {
   1086                      val = pres * div * baudrate - clock;
   \                     ??SDHC_set_baudrate_1: (+1)
   \   0000000E   0xFB05 0xF704      MUL      R7,R5,R4
   \   00000012   0x434F             MULS     R7,R1,R7
   \   00000014   0x1A3F             SUBS     R7,R7,R0
   1087                      if (val >= 0)
   1088                      {
   1089                          if (min > val) 
   \   00000016   0x42B7             CMP      R7,R6
   \   00000018   0xD202             BCS.N    ??SDHC_set_baudrate_2
   1090                          {
   1091                              min = val;
   \   0000001A   0x003E             MOVS     R6,R7
   1092                              minpres = pres;
   \   0000001C   0x0022             MOVS     R2,R4
   1093                              mindiv = div;
   \   0000001E   0x002B             MOVS     R3,R5
   1094                          }
   1095                      }
   1096                  }
   \                     ??SDHC_set_baudrate_2: (+1)
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SDHC_set_baudrate_3: (+1)
   \   00000022   0x2D11             CMP      R5,#+17
   \   00000024   0xD3F3             BCC.N    ??SDHC_set_baudrate_1
   \   00000026   0x0064             LSLS     R4,R4,#+1
   \                     ??SDHC_set_baudrate_0: (+1)
   \   00000028   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000002C   0xD801             BHI.N    ??SDHC_set_baudrate_4
   \   0000002E   0x2501             MOVS     R5,#+1
   \   00000030   0xE7F7             B.N      ??SDHC_set_baudrate_3
   1097              }
   1098          
   1099              //禁止SDHC模块时钟
   1100              SDHC_SYSCTL &= (~ SDHC_SYSCTL_SDCLKEN_MASK);
   \                     ??SDHC_set_baudrate_4: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable8_9  ;; 0x400b102c
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003A   0x....             LDR.N    R1,??DataTable8_9  ;; 0x400b102c
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1101          
   1102              //修改分频因子
   1103              div = SDHC_SYSCTL & (~ (SDHC_SYSCTL_DTOCV_MASK | SDHC_SYSCTL_SDCLKFS_MASK | SDHC_SYSCTL_DVS_MASK));
   \   0000003E   0x....             LDR.N    R0,??DataTable8_9  ;; 0x400b102c
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x0005             MOVS     R5,R0
   \   00000044   0xF36F 0x1513      BFC      R5,#+4,#+16
   1104              SDHC_SYSCTL = div | (SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_SDCLKFS(minpres >> 1) | SDHC_SYSCTL_DVS(mindiv - 1));
   \   00000048   0x01D0             LSLS     R0,R2,#+7
   \   0000004A   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   0000004E   0x4328             ORRS     R0,R0,R5
   \   00000050   0x1E59             SUBS     R1,R3,#+1
   \   00000052   0x0109             LSLS     R1,R1,#+4
   \   00000054   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000058   0x4308             ORRS     R0,R1,R0
   \   0000005A   0xF450 0x2060      ORRS     R0,R0,#0xE0000
   \   0000005E   0x....             LDR.N    R1,??DataTable8_9  ;; 0x400b102c
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1105          
   1106              //等在时钟稳定
   1107              while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB_MASK))
   \                     ??SDHC_set_baudrate_5: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400b1024
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x0700             LSLS     R0,R0,#+28
   \   00000068   0xD405             BMI.N    ??SDHC_set_baudrate_6
   1108              {
   1109                  for(i = 0;i < 200000;i++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??SDHC_set_baudrate_7: (+1)
   \   0000006C   0x....             LDR.N    R1,??DataTable8_34  ;; 0x30d40
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD2F7             BCS.N    ??SDHC_set_baudrate_5
   \   00000072   0x1C40             ADDS     R0,R0,#+1
   \   00000074   0xE7FA             B.N      ??SDHC_set_baudrate_7
   1110                  {
   1111                  }
   1112              };
   1113          
   1114              //使能SDHC模块时钟
   1115              SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN_MASK;
   \                     ??SDHC_set_baudrate_6: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable8_9  ;; 0x400b102c
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000007E   0x....             LDR.N    R1,??DataTable8_9  ;; 0x400b102c
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1116              SDHC_IRQSTAT |= SDHC_IRQSTAT_DTOE_MASK;
   \   00000082   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   0000008A   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1117          }
   \   0000008E   0xBCF0             POP      {R4-R7}
   \   00000090   0x4770             BX       LR               ;; return
   1118          
   1119          //=========================================================================
   1120          //函数名称：SDHC_is_running                                                        
   1121          //功能概要：检测SDHC模块是否忙                                                
   1122          //参数说明：无                              
   1123          //函数返回：1：正忙;0：其他。                                                               
   1124          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
   1125          u8 SDHC_is_running(void)
   1126          {
   1127              return (0 != (SDHC_PRSSTAT & (SDHC_PRSSTAT_RTA_MASK | SDHC_PRSSTAT_WTA_MASK | SDHC_PRSSTAT_DLA_MASK | SDHC_PRSSTAT_CDIHB_MASK | SDHC_PRSSTAT_CIHB_MASK)));
   \                     SDHC_is_running: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400b1024
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF240 0x3107      MOVW     R1,#+775
   \   00000008   0x4208             TST      R0,R1
   \   0000000A   0xD001             BEQ.N    ??SDHC_is_running_0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??SDHC_is_running_1
   \                     ??SDHC_is_running_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??SDHC_is_running_1: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1128          }   
   1129          
   1130          //=========================================================================
   1131          //函数名称：SDHC_status_wait                                                        
   1132          //功能概要：等待中断标志位置位                                                
   1133          //参数说明：mask：待不断的标志位掩码                              
   1134          //函数返回：返回传入的数                                                              
   1135          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
   1136          u32 SDHC_status_wait(u32 mask)
   1137          {
   1138           // uartPrintf("9\n");
   1139            //uartPrintf("%d\n",mask);
   1140            
   1141              u32 result;
   1142              do
   1143              {
   1144                
   1145                  result = SDHC_IRQSTAT & mask;
   \                     SDHC_status_wait: (+1)
   \                     ??SDHC_status_wait_0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x4001             ANDS     R1,R0,R1
   1146          #if PRINT   
   1147                  uartPrintf("%d\n",SDHC_IRQSTAT);
   1148          #endif 
   1149              } 
   1150              while (0 == result);
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD0FA             BEQ.N    ??SDHC_status_wait_0
   1151              return result;
   \   0000000A   0x0008             MOVS     R0,R1
   \   0000000C   0x4770             BX       LR               ;; return
   1152          }
   1153          
   1154          //=========================================================================
   1155          //函数名称：SDHC_send_command                                                        
   1156          //功能概要：发送命令                                                
   1157          //参数说明：command：命令结构体指针                              
   1158          //函数返回：0：成功，1：错误，-1：超时。                                                              
   1159          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
   1160          u32 SDHC_send_command (ESDHC_COMMAND_STRUCT_PTR command)
   1161          {
   \                     SDHC_send_command: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1162            //uartPrintf("开始发送命令\n");
   1163              u32 xfertyp;//Transfer Type Register (SDHC_XFERTYP)
   1164              
   1165              //检查和配置命令
   1166              xfertyp = ESDHC_COMMAND_XFERTYP[command->COMMAND & 0x3F];
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000000A   0x....             LDR.N    R1,??DataTable8_35
   \   0000000C   0xF851 0x5020      LDR      R5,[R1, R0, LSL #+2]
   1167              if ((0 == xfertyp) && (0 != command->COMMAND))
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD104             BNE.N    ??SDHC_send_command_0
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??SDHC_send_command_0
   1168              {
   1169          #if PRINT
   1170                uartPrintf("配置命令不全，返回1\n");
   1171          #endif
   1172               
   1173                
   1174                  return 1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE097             B.N      ??SDHC_send_command_1
   1175              }
   1176              //uartPrintf("1\n");
   1177              //卡移除检测
   1178              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??SDHC_send_command_0: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1179          
   1180              //等待CMD通道空闲
   1181              while (SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB_MASK)
   \                     ??SDHC_send_command_2: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400b1024
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD4FB             BMI.N    ??SDHC_send_command_2
   1182              {
   1183          #if PRINT
   1184                uartPrintf("等待CMD通道空闲\n");
   1185          #endif
   1186                
   1187              }
   1188             
   1189          
   1190              //设置传输类型寄存器参数
   1191              //写命令参数寄存器(Command Argument Register，SDHC_CMDARG)
   1192              SDHC_CMDARG = command->ARGUMENT;
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0x....             LDR.N    R1,??DataTable8_36  ;; 0x400b1008
   \   00000036   0x6008             STR      R0,[R1, #+0]
   1193              //清除XFERTYP寄存器的命令类型域
   1194              xfertyp &= (~ SDHC_XFERTYP_CMDTYP_MASK);
   \   00000038   0xF435 0x0540      BICS     R5,R5,#0xC00000
   1195              //设置XFERTYP寄存器的命令类型域
   1196              xfertyp |= SDHC_XFERTYP_CMDTYP(command->TYPE);
   \   0000003C   0x7860             LDRB     R0,[R4, #+1]
   \   0000003E   0x0580             LSLS     R0,R0,#+22
   \   00000040   0xF410 0x0040      ANDS     R0,R0,#0xC00000
   \   00000044   0x4305             ORRS     R5,R0,R5
   1197              //如果为恢复类型
   1198              if (ESDHC_TYPE_RESUME == command->TYPE)
   \   00000046   0x7860             LDRB     R0,[R4, #+1]
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD101             BNE.N    ??SDHC_send_command_3
   1199              {
   1200                  //如果命令类型为恢复CMD52写功能选择，则置数据传送选择位。
   1201                  xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000004C   0xF455 0x1500      ORRS     R5,R5,#0x200000
   1202              }
   1203              // uartPrintf("3\n");
   1204              //如果是切换忙类型
   1205              if (ESDHC_TYPE_SWITCH_BUSY == command->TYPE)
   \                     ??SDHC_send_command_3: (+1)
   \   00000050   0x7860             LDRB     R0,[R4, #+1]
   \   00000052   0x2804             CMP      R0,#+4
   \   00000054   0xD10D             BNE.N    ??SDHC_send_command_4
   1206              {
   1207                 //uartPrintf("4\n");
   1208              
   1209                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48))
   \   00000056   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   0000005A   0xF5B0 0x3F00      CMP      R0,#+131072
   \   0000005E   0xD104             BNE.N    ??SDHC_send_command_5
   1210                  {
   1211                      xfertyp &= (~ SDHC_XFERTYP_RSPTYP_MASK);
   \   00000060   0xF435 0x3540      BICS     R5,R5,#0x30000
   1212                      xfertyp |= SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY);
   \   00000064   0xF455 0x3540      ORRS     R5,R5,#0x30000
   \   00000068   0xE003             B.N      ??SDHC_send_command_4
   1213                  }
   1214                  else
   1215                  {
   1216                      xfertyp &= (~ SDHC_XFERTYP_RSPTYP_MASK);
   \                     ??SDHC_send_command_5: (+1)
   \   0000006A   0xF435 0x3540      BICS     R5,R5,#0x30000
   1217                      xfertyp |= SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48);
   \   0000006E   0xF455 0x3500      ORRS     R5,R5,#0x20000
   1218                  }
   1219              }
   1220              //清除块数
   1221              SDHC_BLKATTR &= (~ SDHC_BLKATTR_BLKCNT_MASK);
   \                     ??SDHC_send_command_4: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable8_12  ;; 0x400b1004
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000078   0x....             LDR.N    R1,??DataTable8_12  ;; 0x400b1004
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1222               //uartPrintf("5\n");
   1223              //块数判断
   1224              if (0 != command->BLOCKS)
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD01D             BEQ.N    ??SDHC_send_command_6
   1225              {
   1226                // uartPrintf("6\n");
   1227                  //块不为0
   1228                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY))
   \   00000082   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   00000086   0xF5B0 0x3F40      CMP      R0,#+196608
   \   0000008A   0xD001             BEQ.N    ??SDHC_send_command_7
   1229                  {
   1230                      xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000008C   0xF455 0x1500      ORRS     R5,R5,#0x200000
   1231                  }
   1232                  if (command->READ)
   \                     ??SDHC_send_command_7: (+1)
   \   00000090   0x7A20             LDRB     R0,[R4, #+8]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD001             BEQ.N    ??SDHC_send_command_8
   1233                  {
   1234                      xfertyp |= SDHC_XFERTYP_DTDSEL_MASK;    
   \   00000096   0xF055 0x0510      ORRS     R5,R5,#0x10
   1235                  }
   1236                  if (command->BLOCKS > 1)
   \                     ??SDHC_send_command_8: (+1)
   \   0000009A   0x68E0             LDR      R0,[R4, #+12]
   \   0000009C   0x2802             CMP      R0,#+2
   \   0000009E   0xD301             BCC.N    ??SDHC_send_command_9
   1237                  {
   1238                      xfertyp |= SDHC_XFERTYP_MSBSEL_MASK;    
   \   000000A0   0xF055 0x0520      ORRS     R5,R5,#0x20
   1239                  }
   1240                  if ((u32)-1 != command->BLOCKS)
   \                     ??SDHC_send_command_9: (+1)
   \   000000A4   0x68E0             LDR      R0,[R4, #+12]
   \   000000A6   0xF110 0x0F01      CMN      R0,#+1
   \   000000AA   0xD008             BEQ.N    ??SDHC_send_command_6
   1241                  {
   1242                      SDHC_BLKATTR |= SDHC_BLKATTR_BLKCNT(command->BLOCKS);
   \   000000AC   0x....             LDR.N    R0,??DataTable8_12  ;; 0x400b1004
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x68E1             LDR      R1,[R4, #+12]
   \   000000B2   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000000B6   0x....             LDR.N    R1,??DataTable8_12  ;; 0x400b1004
   \   000000B8   0x6008             STR      R0,[R1, #+0]
   1243                   //    uartPrintf("7\n");
   1244                      xfertyp |= SDHC_XFERTYP_BCEN_MASK;
   \   000000BA   0xF055 0x0502      ORRS     R5,R5,#0x2
   1245                  }
   1246              }
   1247          
   1248              //执行命令
   1249              SDHC_DSADDR = 0;
   \                     ??SDHC_send_command_6: (+1)
   \   000000BE   0x....             LDR.N    R0,??DataTable8_37  ;; 0x400b1000
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x6001             STR      R1,[R0, #+0]
   1250              SDHC_XFERTYP = xfertyp;
   \   000000C4   0x....             LDR.N    R0,??DataTable8_38  ;; 0x400b100c
   \   000000C6   0x6005             STR      R5,[R0, #+0]
   1251             // uartPrintf("8\n");
   1252              //等待状态寄存器置位
   1253              if (SDHC_status_wait (SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK) != SDHC_IRQSTAT_CC_MASK)
   \   000000C8   0x....             LDR.N    R0,??DataTable8_39  ;; 0xe0001
   \   000000CA   0x.... 0x....      BL       SDHC_status_wait
   \   000000CE   0x2801             CMP      R0,#+1
   \   000000D0   0xD009             BEQ.N    ??SDHC_send_command_10
   1254              {
   1255                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000D2   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0xF440 0x2070      ORR      R0,R0,#0xF0000
   \   000000DA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000DE   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   000000E0   0x6008             STR      R0,[R1, #+0]
   1256          #if PRINT
   1257                  uartPrintf("等待卡置位\n");
   1258          #endif 
   1259                  return 1;
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xE033             B.N      ??SDHC_send_command_1
   1260              }
   1261          
   1262              //检测卡是否被移除
   1263              if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \                     ??SDHC_send_command_10: (+1)
   \   000000E6   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x0600             LSLS     R0,R0,#+24
   \   000000EC   0xD507             BPL.N    ??SDHC_send_command_11
   1264              {
   1265                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000EE   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   000000F6   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   000000F8   0x6008             STR      R0,[R1, #+0]
   1266          #if PRINT
   1267                  uartPrintf("检测卡是否移除\n");
   1268          #endif
   1269                  
   1270                  return 1;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0xE027             B.N      ??SDHC_send_command_1
   1271              }
   1272          
   1273              //检查命令是否超时
   1274              if (SDHC_IRQSTAT & SDHC_IRQSTAT_CTOE_MASK)
   \                     ??SDHC_send_command_11: (+1)
   \   000000FE   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x03C0             LSLS     R0,R0,#+15
   \   00000104   0xD508             BPL.N    ??SDHC_send_command_12
   1275              {
   1276                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   00000106   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   0000010E   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   00000110   0x6008             STR      R0,[R1, #+0]
   1277          #if PRINT
   1278                  uartPrintf("检查命令是否超时\n");
   1279          #endif
   1280                  return -1;
   \   00000112   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000116   0xE01A             B.N      ??SDHC_send_command_1
   1281              }
   1282              if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO))
   \                     ??SDHC_send_command_12: (+1)
   \   00000118   0xF415 0x3F40      TST      R5,#0x30000
   \   0000011C   0xD010             BEQ.N    ??SDHC_send_command_13
   1283              {
   1284                  command->RESPONSE[0] = SDHC_CMDRSP(0);
   \   0000011E   0x....             LDR.N    R0,??DataTable8_40  ;; 0x400b1010
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x6120             STR      R0,[R4, #+16]
   1285                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136))
   \   00000124   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   00000128   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000012C   0xD108             BNE.N    ??SDHC_send_command_13
   1286                  {
   1287                      command->RESPONSE[1] = SDHC_CMDRSP(1);
   \   0000012E   0x....             LDR.N    R0,??DataTable8_41  ;; 0x400b1014
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0x6160             STR      R0,[R4, #+20]
   1288                      command->RESPONSE[2] = SDHC_CMDRSP(2);
   \   00000134   0x....             LDR.N    R0,??DataTable8_42  ;; 0x400b1018
   \   00000136   0x6800             LDR      R0,[R0, #+0]
   \   00000138   0x61A0             STR      R0,[R4, #+24]
   1289                      command->RESPONSE[3] = SDHC_CMDRSP(3);
   \   0000013A   0x....             LDR.N    R0,??DataTable8_43  ;; 0x400b101c
   \   0000013C   0x6800             LDR      R0,[R0, #+0]
   \   0000013E   0x61E0             STR      R0,[R4, #+28]
   1290                  }
   1291              }
   1292              
   1293              SDHC_IRQSTAT |= SDHC_IRQSTAT_CC_MASK;
   \                     ??SDHC_send_command_13: (+1)
   \   00000140   0x....             LDR.N    R0,??DataTable8_22  ;; 0x400b1030
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000148   0x....             LDR.N    R1,??DataTable8_22  ;; 0x400b1030
   \   0000014A   0x6008             STR      R0,[R1, #+0]
   1294          
   1295              return 0;
   \   0000014C   0x2000             MOVS     R0,#+0
   \                     ??SDHC_send_command_1: (+1)
   \   0000014E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1296          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x4007C008         DC32     0x4007c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     SDHC_Card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x400B102C         DC32     0x400b102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x400B10C0         DC32     0x400b10c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x400B1004         DC32     0x400b1004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x400B1028         DC32     0x400b1028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x400B1044         DC32     0x400b1044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \   00000000   0x400B1034         DC32     0x400b1034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_24:
   \   00000000   0x007F00B3         DC32     0x7f00b3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_25:
   \   00000000   0x400B1020         DC32     0x400b1020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_26:
   \   00000000   0x........         DC32     `?<Constant "\\265\\310\\264\\375\\312\\375\\276\\335\\n`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_27:
   \   00000000   0x........         DC32     `?<Constant "\\264\\355\\316\\363\\267\\265\\273\\3301\\`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_28:
   \   00000000   0x........         DC32     `?<Constant "\\313\\371\\323\\320\\312\\375\\276\\335\\2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_29:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_30:
   \   00000000   0x05B8D800         DC32     0x5b8d800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_31:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_32:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_33:
   \   00000000   0x40300000         DC32     0x40300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_34:
   \   00000000   0x00030D40         DC32     0x30d40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_35:
   \   00000000   0x........         DC32     ESDHC_COMMAND_XFERTYP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_36:
   \   00000000   0x400B1008         DC32     0x400b1008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_37:
   \   00000000   0x400B1000         DC32     0x400b1000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_38:
   \   00000000   0x400B100C         DC32     0x400b100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_39:
   \   00000000   0x000E0001         DC32     0xe0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_40:
   \   00000000   0x400B1010         DC32     0x400b1010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_41:
   \   00000000   0x400B1014         DC32     0x400b1014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_42:
   \   00000000   0x400B1018         DC32     0x400b1018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_43:
   \   00000000   0x400B101C         DC32     0x400b101c

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\264\\355\\316\\363\\267\\265\\273\\3301\\`:
   \   00000000   0xB4 0xED          DC8 "\264\355\316\363\267\265\273\3301\012"
   \              0xCE 0xF3    
   \              0xB7 0xB5    
   \              0xBB 0xD8    
   \              0x31 0x0A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\265\\310\\264\\375\\312\\375\\276\\335\\n`:
   \   00000000   0xB5 0xC8          DC8 "\265\310\264\375\312\375\276\335\012"
   \              0xB4 0xFD    
   \              0xCA 0xFD    
   \              0xBE 0xDD    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\313\\371\\323\\320\\312\\375\\276\\335\\2`:
   \   00000000   0xCB 0xF9          DC8 "\313\371\323\320\312\375\276\335\267\242\313\315\315\352\261\317\012"
   \              0xD3 0xD0    
   \              0xCA 0xFD    
   \              0xBE 0xDD    
   \              0xB7 0xA2    
   \              0xCB 0xCD    
   \              0xCD 0xEA    
   \              0xB1 0xCF    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
   1297          
   1298          
   1299          #ifdef  __cplusplus
   1300          }
   1301          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   PLL_Init
         8   -> SetSysDividers
       8   SDHC_init
         8   -> SDHC_set_baudrate
      64   SDHC_ioctl
        64   -> SDHC_init
        64   -> SDHC_is_running
        64   -> SDHC_send_command
        64   -> SDHC_set_baudrate
       0   SDHC_is_running
       4   SDHC_receive_block
      24   SDHC_send_block
        24   -> uartPrintf
      16   SDHC_send_command
        16   -> SDHC_status_wait
      16   SDHC_set_baudrate
       0   SDHC_status_wait
      12   SetSysDividers


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "\264\355\316\363\267\265\273\3301\
      12  ?<Constant "\265\310\264\375\312\375\276\335\n
      20  ?<Constant "\313\371\323\320\312\375\276\335\2
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_23
       4  ??DataTable8_24
       4  ??DataTable8_25
       4  ??DataTable8_26
       4  ??DataTable8_27
       4  ??DataTable8_28
       4  ??DataTable8_29
       4  ??DataTable8_3
       4  ??DataTable8_30
       4  ??DataTable8_31
       4  ??DataTable8_32
       4  ??DataTable8_33
       4  ??DataTable8_34
       4  ??DataTable8_35
       4  ??DataTable8_36
       4  ??DataTable8_37
       4  ??DataTable8_38
       4  ??DataTable8_39
       4  ??DataTable8_4
       4  ??DataTable8_40
       4  ??DataTable8_41
       4  ??DataTable8_42
       4  ??DataTable8_43
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
     256  ESDHC_COMMAND_XFERTYP
     158  PLL_Init
     242  SDHC_init
    1254  SDHC_ioctl
      22  SDHC_is_running
     148  SDHC_receive_block
     114  SDHC_send_block
     336  SDHC_send_command
     146  SDHC_set_baudrate
      14  SDHC_status_wait
      76  SetSysDividers

 
   300 bytes in section .rodata
 2 610 bytes in section .text
    76 bytes in section .textrw
 
 2 686 bytes of CODE  memory
   300 bytes of CONST memory

Errors: none
Warnings: 3

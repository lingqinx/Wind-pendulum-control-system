###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      15/Aug/2015  19:53:02 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\F #
#                    lash\flash.c                                             #
#    Command line =  C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\F #
#                    lash\flash.c -lCN C:\Users\Administrator\Desktop\MPU6050 #
#                    8.12\build\gpio_demo\FLASH\List\ -lB                     #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\ -o C:\Users\Administrator\Desktop\MPU6050 #
#                    8.12\build\gpio_demo\FLASH\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\IAR Systems\Embedded     #
#                    Workbench 6.5\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\ -I C:\Users\Administrator\Desktop\MPU60508.12\bui #
#                    ld\gpio_demo\..\..\src\common\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\cpu\ -I C:\Users\Administrator\Desktop\MPU6 #
#                    0508.12\build\gpio_demo\..\..\src\drivers\ -I            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\gpio\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\olcd\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\diskio\ -I                          #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\iospi\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\wdog\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\mcg\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\flash\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\uart\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\lptmr\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\LED\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\fun\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\FTM\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\pit\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\DIPswitch\ -I                       #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\motor\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\laser\ -I                           #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\i2c\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\ADdevice\ -I                        #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\adc\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\serial_digtal_scope\ -I             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MMA845x\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\exti\ -I                            #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\dma\ -I                             #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\platforms\ -I C:\Users\Administrator\Deskto #
#                    p\MPU60508.12\build\gpio_demo\..\..\src\projects\ -I     #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\projects\gpio_demo\ -I                      #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\MPU6050\ -I                         #
#                    C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\..\..\src\drivers\steer\ -Ol                          #
#    List file    =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\List\flash.lst                                  #
#    Object file  =  C:\Users\Administrator\Desktop\MPU60508.12\build\gpio_de #
#                    mo\FLASH\Obj\flash.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\MPU60508.12\src\drivers\Flash\flash.c
      1          /*
      2          ************************************************************************
      3          *                北京邮电大学 K60 学习例程 
      4          * 文件名 :[flash.c] 
      5          * 描  述 ：flash驱动函数
      6          *设计改进：snowwolf
      7          *  Email ：snowwolf2012@qq.com
      8          * 说  明 ：flash驱动函数
      9          * 备注	：从苏州大学例程修改而成
     10          *     K60的程序Flash，每个扇区 2K
     11          *	k60N512包含512K的程序Flash ， 即扇区总数为256 ，即扇区取值范围为 0~255
     12          *	k60X256包含256K的程序Flash ， 即扇区总数为128 ，即扇区取值范围为 0~127
     13          *	注意，扇区，请尽量用最后面的扇区，最前面的扇区，通常都是存放代码的。
     14          *		有可能破坏了前面的代码！！！！
     15          ************************************************************************
     16          */
     17          
     18          
     19          //包含头文件
     20          #include "flash.h" 
     21          #include "global.h"
     22          #include "common.h"
     23          

   \                                 In section .bss, align 4
     24          uint32 FlashData[FLASH_BUFFER_MAX] = {0};
   \                     FlashData:
   \   00000000                      DS8 160
     25          
     26          //Flash命令宏定义，内部使用
     27          #define   RD1BLK    0x00   // 读整块Flash
     28          #define   RD1SEC    0x01   // 读整个扇区
     29          #define   PGMCHK    0x02   // 写入检查
     30          #define   RDRSRC    0x03   // 读目标数据
     31          #define   PGM4      0x06   // 写入长字
     32          #define   ERSBLK    0x08   // 擦除整块Flash
     33          #define   ERSSCR    0x09   // 擦除Flash扇区
     34          #define   PGMSEC    0x0B   // 写入扇区
     35          #define   RD1ALL    0x40   // 读所有的块
     36          #define   RDONCE    0x41   // 只读一次
     37          #define   PGMONCE   0x43   // 只写一次
     38          #define   ERSALL    0x44   // 擦除所有块
     39          #define   VFYKEY    0x45   // 验证后门访问钥匙
     40          #define   PGMPART   0x80   // 写入分区
     41          #define   SETRAM    0x81   // 设定FlexRAM功能
     42          
     43          
     44          #define VAR00  time
     45          #define VAR01  speed_duty
     46          #define VAR02  steer_dp
     47          #define VAR03  steer_dd
     48          #define VAR04  line_first
     49          #define VAR05  line_second
     50          #define VAR06  line_third
     51          #define VAR07  line_fourth
     52          #define VAR08  k_1
     53          #define VAR09  k_2
     54          #define VAR10  k_3
     55          #define VAR11  k_4
     56          
     57          void FlashDataInit() ;
     58          void ReadFlashData() ;
     59          /***************************************************
     60          ** 函数名称: void SetUserFlash(byte cho) 
     61          ** 功能描述: 将用户变量与falsh缓存关联
     62          **  入  口 ：
     63          **  出  口 ：
     64          **  说  明 : 可以在这里把要存到flash中的变量与flash
     65                       关联，最多32个int变量  
     66          ****************************************************/

   \                                 In section .text, align 2, keep-with-next
     67          void SetUserFlash(byte cho) 
     68          {
     69               //将用户数据放回到flash缓冲区
     70               if(cho == 1) 
   \                     SetUserFlash: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD130             BNE.N    ??SetUserFlash_0
     71               {
     72                 
     73                   FlashData[0]  = VAR00;
   \   00000006   0x....             LDR.N    R0,??DataTable3
   \   00000008   0x....             LDR.N    R1,??DataTable3_1
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x6001             STR      R1,[R0, #+0]
     74                   FlashData[1]  = VAR01;
   \   0000000E   0x....             LDR.N    R0,??DataTable3
   \   00000010   0x....             LDR.N    R1,??DataTable3_2
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x6041             STR      R1,[R0, #+4]
     75                   FlashData[2]  = VAR02;
   \   00000016   0x....             LDR.N    R0,??DataTable3
   \   00000018   0x....             LDR.N    R1,??DataTable3_3
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x6081             STR      R1,[R0, #+8]
     76                   FlashData[3]  = VAR03;
   \   0000001E   0x....             LDR.N    R0,??DataTable3
   \   00000020   0x....             LDR.N    R1,??DataTable3_4
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x60C1             STR      R1,[R0, #+12]
     77                   FlashData[4]  = VAR04;
   \   00000026   0x....             LDR.N    R0,??DataTable3
   \   00000028   0x....             LDR.N    R1,??DataTable3_5
   \   0000002A   0x7809             LDRB     R1,[R1, #+0]
   \   0000002C   0x6101             STR      R1,[R0, #+16]
     78                   FlashData[5]  = VAR05;
   \   0000002E   0x....             LDR.N    R0,??DataTable3
   \   00000030   0x....             LDR.N    R1,??DataTable3_6
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0x6141             STR      R1,[R0, #+20]
     79                   FlashData[6]  = VAR06;
   \   00000036   0x....             LDR.N    R0,??DataTable3
   \   00000038   0x....             LDR.N    R1,??DataTable3_7
   \   0000003A   0x7809             LDRB     R1,[R1, #+0]
   \   0000003C   0x6181             STR      R1,[R0, #+24]
     80                   FlashData[7]  = VAR07;
   \   0000003E   0x....             LDR.N    R0,??DataTable3
   \   00000040   0x....             LDR.N    R1,??DataTable3_8
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x61C1             STR      R1,[R0, #+28]
     81                   FlashData[8]  = VAR08;
   \   00000046   0x....             LDR.N    R0,??DataTable3
   \   00000048   0x....             LDR.N    R1,??DataTable3_9
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x6201             STR      R1,[R0, #+32]
     82                   FlashData[9]  = VAR09;
   \   0000004E   0x....             LDR.N    R0,??DataTable3
   \   00000050   0x....             LDR.N    R1,??DataTable3_10
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x6241             STR      R1,[R0, #+36]
     83                   FlashData[10] = VAR10;
   \   00000056   0x....             LDR.N    R0,??DataTable3
   \   00000058   0x....             LDR.N    R1,??DataTable3_11
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x6281             STR      R1,[R0, #+40]
     84                   FlashData[11] = VAR11;
   \   0000005E   0x....             LDR.N    R0,??DataTable3
   \   00000060   0x....             LDR.N    R1,??DataTable3_12
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x62C1             STR      R1,[R0, #+44]
   \   00000066   0xE032             B.N      ??SetUserFlash_1
     85                   
     86               } //将flash缓冲区中数据放到到用户变量中
     87               else  if(cho == 0) 
   \                     ??SetUserFlash_0: (+1)
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD12F             BNE.N    ??SetUserFlash_1
     88               {
     89                   VAR00 = FlashData[0];
   \   0000006E   0x....             LDR.N    R0,??DataTable3_1
   \   00000070   0x....             LDR.N    R1,??DataTable3
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x7001             STRB     R1,[R0, #+0]
     90                   VAR01 = FlashData[1];
   \   00000076   0x....             LDR.N    R0,??DataTable3
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0x....             LDR.N    R1,??DataTable3_2
   \   0000007C   0x6008             STR      R0,[R1, #+0]
     91                   VAR02 = FlashData[2];
   \   0000007E   0x....             LDR.N    R0,??DataTable3
   \   00000080   0x6880             LDR      R0,[R0, #+8]
   \   00000082   0x....             LDR.N    R1,??DataTable3_3
   \   00000084   0x6008             STR      R0,[R1, #+0]
     92                   VAR03 = FlashData[3];
   \   00000086   0x....             LDR.N    R0,??DataTable3
   \   00000088   0x68C0             LDR      R0,[R0, #+12]
   \   0000008A   0x....             LDR.N    R1,??DataTable3_4
   \   0000008C   0x6008             STR      R0,[R1, #+0]
     93                   VAR04 = FlashData[4];
   \   0000008E   0x....             LDR.N    R0,??DataTable3
   \   00000090   0x6900             LDR      R0,[R0, #+16]
   \   00000092   0x....             LDR.N    R1,??DataTable3_5
   \   00000094   0x7008             STRB     R0,[R1, #+0]
     94                   VAR05 = FlashData[5];
   \   00000096   0x....             LDR.N    R0,??DataTable3
   \   00000098   0x6940             LDR      R0,[R0, #+20]
   \   0000009A   0x....             LDR.N    R1,??DataTable3_6
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
     95                   VAR06 = FlashData[6];
   \   0000009E   0x....             LDR.N    R0,??DataTable3
   \   000000A0   0x6980             LDR      R0,[R0, #+24]
   \   000000A2   0x....             LDR.N    R1,??DataTable3_7
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
     96                   VAR07 = FlashData[7];
   \   000000A6   0x....             LDR.N    R0,??DataTable3
   \   000000A8   0x69C0             LDR      R0,[R0, #+28]
   \   000000AA   0x....             LDR.N    R1,??DataTable3_8
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
     97                   VAR08 = FlashData[8];
   \   000000AE   0x....             LDR.N    R0,??DataTable3
   \   000000B0   0x6A00             LDR      R0,[R0, #+32]
   \   000000B2   0x....             LDR.N    R1,??DataTable3_9
   \   000000B4   0x6008             STR      R0,[R1, #+0]
     98                   VAR09 = FlashData[9];
   \   000000B6   0x....             LDR.N    R0,??DataTable3
   \   000000B8   0x6A40             LDR      R0,[R0, #+36]
   \   000000BA   0x....             LDR.N    R1,??DataTable3_10
   \   000000BC   0x6008             STR      R0,[R1, #+0]
     99                   VAR10 = FlashData[10];
   \   000000BE   0x....             LDR.N    R0,??DataTable3
   \   000000C0   0x6A80             LDR      R0,[R0, #+40]
   \   000000C2   0x....             LDR.N    R1,??DataTable3_11
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    100                   VAR11 = FlashData[11];
   \   000000C6   0x....             LDR.N    R0,??DataTable3
   \   000000C8   0x6AC0             LDR      R0,[R0, #+44]
   \   000000CA   0x....             LDR.N    R1,??DataTable3_12
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    101                   
    102               }
    103          
    104          }
   \                     ??SetUserFlash_1: (+1)
   \   000000CE   0x4770             BX       LR               ;; return
    105          
    106          
    107          
    108          /*************************************************************************
    109          *  函数名称：flash_cmd_launch
    110          *  功能说明：启动Flash命令
    111          *  参数说明：无
    112          *  函数返回：0-成功 1-失败
    113          *  修改时间：2012-6-11    已测试
    114          *  备    注：内部函数实现
    115          *************************************************************************/

   \                                 In section .textrw, align 2, keep-with-next
    116          __RAMFUN static uint32 flash_cmd_launch(void)
    117          {
    118              
    119              FTFL_FSTAT = 	(0
    120          				  	|	FTFL_FSTAT_CCIF_MASK 		// 启动命令
    121          					|	FTFL_FSTAT_ACCERR_MASK 		// 清除访问错误标志位
    122          					| 	FTFL_FSTAT_FPVIOL_MASK		// 非法访问标志位
    123          					);	
   \                     flash_cmd_launch: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable21  ;; 0x40020000
   \   00000002   0x21B0             MOVS     R1,#+176
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    124              									
    125              while(!(FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK));	// 等待命令完成
   \                     ??flash_cmd_launch_0: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable21  ;; 0x40020000
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x0600             LSLS     R0,R0,#+24
   \   0000000C   0xD5FB             BPL.N    ??flash_cmd_launch_0
    126          
    127              // 检查错误标志
    128              if( FTFL_FSTAT & (FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_FPVIOL_MASK | FTFL_FSTAT_MGSTAT0_MASK))
   \   0000000E   0x....             LDR.N    R0,??DataTable21  ;; 0x40020000
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2131             MOVS     R1,#+49
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD001             BEQ.N    ??flash_cmd_launch_1
    129                  return 1 ; 				//执行命令出错
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??flash_cmd_launch_2
    130            
    131              return 0; 					//执行命令成功
   \                     ??flash_cmd_launch_1: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??flash_cmd_launch_2: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    132          }
    133          /*************************************************************************
    134          *  函数名称：flash_init
    135          *  功能说明：初始化flash模块
    136          *  参数说明：无
    137          *  函数返回：无
    138          *  修改时间：2012-6-11    已测试
    139          *  备    注：外部接口函数
    140          *************************************************************************/

   \                                 In section .textrw, align 2, keep-with-next
    141          __RAMFUN void flash_init(void)
    142          {
    143          	// 清除Flash预读取缓冲区
    144              FMC_PFB0CR |= FMC_PFB0CR_S_B_INV_MASK;
   \                     flash_init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable21_1  ;; 0x4001f004
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000008   0x....             LDR.N    R1,??DataTable21_1  ;; 0x4001f004
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    145              FMC_PFB1CR |= FMC_PFB0CR_S_B_INV_MASK;
   \   0000000C   0x....             LDR.N    R0,??DataTable21_2  ;; 0x4001f008
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000014   0x....             LDR.N    R1,??DataTable21_2  ;; 0x4001f008
   \   00000016   0x6008             STR      R0,[R1, #+0]
    146              
    147              while(!(FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK));	// 等待命令完成
   \                     ??flash_init_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable21  ;; 0x40020000
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x0600             LSLS     R0,R0,#+24
   \   0000001E   0xD5FB             BPL.N    ??flash_init_0
    148              
    149              FTFL_FSTAT = (0
    150                          |FTFL_FSTAT_ACCERR_MASK 		// 清除访问错误标志位
    151                          |FTFL_FSTAT_FPVIOL_MASK		// 非法访问标志位
    152                          );	
   \   00000020   0x....             LDR.N    R0,??DataTable21  ;; 0x40020000
   \   00000022   0x2130             MOVS     R1,#+48
   \   00000024   0x7001             STRB     R1,[R0, #+0]
    153          }
   \   00000026   0x4770             BX       LR               ;; return
    154          
    155          
    156          /*************************************************************************
    157          *  函数名称：flash_erase_sector
    158          *  功能说明：擦除指定flash扇区
    159          *  参数说明：sectorNo：扇区号（K60N512实际使用0~255）
    160          *  函数返回：函数执行执行状态：0=正常；非0=异常。
    161          *  修改时间：2012-6-11    已测试
    162          *  备    注：外部接口函数
    163          *************************************************************************/

   \                                 In section .textrw, align 2, keep-with-next
    164          __RAMFUN uint8 flash_erase_sector(uint16 sectorNo)
    165          {
   \                     flash_erase_sector: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    166              Dtype	addr;	
    167          	addr.DW = (uint32)(sectorNo<<11);	//每个扇区2KB，所以扇区地址=扇区号*2K ，这里用 <<11 表示 *2*1024 
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0x02E0             LSLS     R0,R4,#+11
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    168              
    169              //dest.word    = (uint32)(sectorNo<<11);	//每个扇区2KB，所以扇区地址=扇区号*2K ，这里用 <<11 表示 *2*1024 
    170          
    171              // 设置擦除命令
    172              FTFL_FCCOB0 = ERSSCR; // 擦除扇区命令
   \   0000000C   0x....             LDR.N    R0,??DataTable21_3  ;; 0x40020007
   \   0000000E   0x2109             MOVS     R1,#+9
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    173              
    174              // 设置目标地址
    175              FTFL_FCCOB1 = addr.B[2];
   \   00000012   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000016   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40020006
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    176              FTFL_FCCOB2 = addr.B[1];
   \   0000001A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000001E   0x....             LDR.N    R1,??DataTable21_5  ;; 0x40020005
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    177              FTFL_FCCOB3 = addr.B[0];
   \   00000022   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40020004
   \   00000024   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    178              
    179              // 执行命令序列
    180              if(1 == flash_cmd_launch())    //若执行命令出现错误
   \   0000002A   0x.... 0x....      BL       flash_cmd_launch
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??flash_erase_sector_0
    181                  return 1;     //擦除命令错误
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE021             B.N      ??flash_erase_sector_1
    182             
    183              // 若擦除sector0时，则解锁设备
    184              if(sectorNo ==0)
   \                     ??flash_erase_sector_0: (+1)
   \   00000036   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD11D             BNE.N    ??flash_erase_sector_2
    185              {
    186                  // 写入4字节
    187                  FTFL_FCCOB0 = PGM4; 
   \   0000003C   0x....             LDR.N    R0,??DataTable21_3  ;; 0x40020007
   \   0000003E   0x2106             MOVS     R1,#+6
   \   00000040   0x7001             STRB     R1,[R0, #+0]
    188                  // 设置目标地址
    189                  FTFL_FCCOB1 = 0x00;
   \   00000042   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40020006
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x7001             STRB     R1,[R0, #+0]
    190                  FTFL_FCCOB2 = 0x04;
   \   00000048   0x....             LDR.N    R0,??DataTable21_5  ;; 0x40020005
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x7001             STRB     R1,[R0, #+0]
    191                  FTFL_FCCOB3 = 0x0C;
   \   0000004E   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40020004
   \   00000050   0x210C             MOVS     R1,#+12
   \   00000052   0x7001             STRB     R1,[R0, #+0]
    192                  // 数据
    193                  FTFL_FCCOB4 = 0xFF;
   \   00000054   0x....             LDR.N    R0,??DataTable21_7  ;; 0x4002000b
   \   00000056   0x21FF             MOVS     R1,#+255
   \   00000058   0x7001             STRB     R1,[R0, #+0]
    194                  FTFL_FCCOB5 = 0xFF;
   \   0000005A   0x....             LDR.N    R0,??DataTable21_8  ;; 0x4002000a
   \   0000005C   0x21FF             MOVS     R1,#+255
   \   0000005E   0x7001             STRB     R1,[R0, #+0]
    195                  FTFL_FCCOB6 = 0xFF;
   \   00000060   0x....             LDR.N    R0,??DataTable21_9  ;; 0x40020009
   \   00000062   0x21FF             MOVS     R1,#+255
   \   00000064   0x7001             STRB     R1,[R0, #+0]
    196                  FTFL_FCCOB7 = 0xFE;
   \   00000066   0x....             LDR.N    R0,??DataTable21_10  ;; 0x40020008
   \   00000068   0x21FE             MOVS     R1,#+254
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
    197                  // 执行命令序列
    198                  if(1 == flash_cmd_launch())  //若执行命令出现错误
   \   0000006C   0x.... 0x....      BL       flash_cmd_launch
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD101             BNE.N    ??flash_erase_sector_2
    199                      return 2;   //解锁命令错误
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0xE000             B.N      ??flash_erase_sector_1
    200              }  
    201              
    202              return 0;  //成功返回
   \                     ??flash_erase_sector_2: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \                     ??flash_erase_sector_1: (+1)
   \   0000007A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    203          }
    204          /*************************************************************************
    205          *  函数名称：flash_write
    206          *  功能说明：擦除指定flash扇区
    207          *  参数说明：sectorNo：目标扇区号 （K60N512实际使用0~255）
    208          *            offset:写入扇区内部偏移地址（0~2043）     
    209          *            data：源数据
    210          *  函数返回：函数执行状态：0=正常；非0=异常。
    211          *  修改时间：2012-6-11    已测试
    212          *  备    注：flash写入操作
    213          *************************************************************************/

   \                                 In section .textrw, align 2, keep-with-next
    214          __RAMFUN uint8 flash_write(uint16 sectorNo,uint16 offset,uint32 data)
    215          {
   \                     flash_write: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    216              Dtype	addr;	
    217              Dtype	Data;
    218              
    219              ASSERT(offset%4 == 0);			//偏移量必须为4的倍数
   \   00000008   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xFB96 0xF1F0      SDIV     R1,R6,R0
   \   00000010   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD003             BEQ.N    ??flash_write_0
   \   00000018   0x21DB             MOVS     R1,#+219
   \   0000001A   0x....             LDR.N    R0,??DataTable21_11
   \   0000001C   0x.... 0x....      BL       assert_failed
    220                                                                              //此处提示警告，但是安全的……
    221              ASSERT(offset <= 0x800);		//扇区大小为2K，即偏移量必须不大于 0x800
   \                     ??flash_write_0: (+1)
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0xF5B6 0x6F00      CMP      R6,#+2048
   \   00000026   0xDD03             BLE.N    ??flash_write_1
   \   00000028   0x21DD             MOVS     R1,#+221
   \   0000002A   0x....             LDR.N    R0,??DataTable21_11
   \   0000002C   0x.... 0x....      BL       assert_failed
    222                                                                              //此处提示警告，但是安全的……
    223              
    224              addr.DW = (uint32)((sectorNo<<11) + offset);		//计算地址
   \                     ??flash_write_1: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x02E8             LSLS     R0,R5,#+11
   \   00000034   0xFA10 0xF086      UXTAH    R0,R0,R6
   \   00000038   0x9001             STR      R0,[SP, #+4]
    225              Data.DW	= data;	
   \   0000003A   0x9400             STR      R4,[SP, #+0]
    226                  
    227              FTFL_FCCOB0 = PGM4;				// 设置写入命令
   \   0000003C   0x....             LDR.N    R0,??DataTable21_3  ;; 0x40020007
   \   0000003E   0x2106             MOVS     R1,#+6
   \   00000040   0x7001             STRB     R1,[R0, #+0]
    228              
    229              FTFL_FCCOB1 = addr.B[2];		// 设置目标地址
   \   00000042   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000046   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40020006
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    230              FTFL_FCCOB2 = addr.B[1];
   \   0000004A   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000004E   0x....             LDR.N    R1,??DataTable21_5  ;; 0x40020005
   \   00000050   0x7008             STRB     R0,[R1, #+0]
    231              FTFL_FCCOB3 = addr.B[0];
   \   00000052   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40020004
   \   00000054   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000058   0x7001             STRB     R1,[R0, #+0]
    232              
    233              
    234              FTFL_FCCOB4 = Data.B[3];        // 设置写入数据
   \   0000005A   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000005E   0x....             LDR.N    R1,??DataTable21_7  ;; 0x4002000b
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    235              FTFL_FCCOB5 = Data.B[2];
   \   00000062   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000066   0x....             LDR.N    R1,??DataTable21_8  ;; 0x4002000a
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    236              FTFL_FCCOB6 = Data.B[1];
   \   0000006A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000006E   0x....             LDR.N    R1,??DataTable21_9  ;; 0x40020009
   \   00000070   0x7008             STRB     R0,[R1, #+0]
    237              FTFL_FCCOB7 = Data.B[0];
   \   00000072   0x....             LDR.N    R0,??DataTable21_10  ;; 0x40020008
   \   00000074   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000078   0x7001             STRB     R1,[R0, #+0]
    238              
    239              if(1 == flash_cmd_launch()) 	return 2;  //写入命令错误
   \   0000007A   0x.... 0x....      BL       flash_cmd_launch
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD101             BNE.N    ??flash_write_2
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0xE000             B.N      ??flash_write_3
    240          
    241              return 0;  //成功执行
   \                     ??flash_write_2: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??flash_write_3: (+1)
   \   00000088   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    242          }
    243          
    244          
    245          /*************************************************************************
    246          *  函数名称：flash_write_buf
    247          *  功能说明：擦除指定flash扇区
    248          *  参数说明：sectorNo：目标扇区号 （K60N512实际使用0~255）
    249          *            offset:写入扇区内部偏移地址（0~2043）     
    250          *            cnt：写入字节数目（0~2043）
    251          *            buf：源数据缓冲区首地址
    252          *  函数返回：函数执行状态：0=正常；非0=异常。
    253          *  修改时间：2012-6-11    已测试
    254          *  备    注：flash写入操作
    255          *************************************************************************/

   \                                 In section .textrw, align 2, keep-with-next
    256          __RAMFUN uint8 flash_write_buf(uint16 sectorNo,uint16 offset,uint16 cnt,uint8 buf[])
    257          {
   \                     flash_write_buf: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x001D             MOVS     R5,R3
    258              uint32 size;
    259           
    260              Dtype	addr;	
    261          
    262              ASSERT(offset%4 == 0);			//偏移量必须为4的倍数
   \   0000000A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xFB96 0xF1F0      SDIV     R1,R6,R0
   \   00000012   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD004             BEQ.N    ??flash_write_buf_0
   \   0000001A   0xF44F 0x7183      MOV      R1,#+262
   \   0000001E   0x....             LDR.N    R0,??DataTable21_11
   \   00000020   0x.... 0x....      BL       assert_failed
    263                                                                              //此处提示警告，但是安全的……
    264              ASSERT(offset <= 0x800);		//扇区大小为2K，即偏移量必须不大于 0x800
   \                     ??flash_write_buf_0: (+1)
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0xF5B6 0x6F00      CMP      R6,#+2048
   \   0000002A   0xDD04             BLE.N    ??flash_write_buf_1
   \   0000002C   0xF44F 0x7184      MOV      R1,#+264
   \   00000030   0x....             LDR.N    R0,??DataTable21_11
   \   00000032   0x.... 0x....      BL       assert_failed
    265                                                                              //此处提示警告，但是安全的……
    266              ASSERT((offset + cnt*4) <= 0x800);        //只能在当前块操作
   \                     ??flash_write_buf_1: (+1)
   \   00000036   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000038   0x00A0             LSLS     R0,R4,#+2
   \   0000003A   0xFA10 0xF086      UXTAH    R0,R0,R6
   \   0000003E   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000042   0xDD04             BLE.N    ??flash_write_buf_2
   \   00000044   0xF44F 0x7185      MOV      R1,#+266
   \   00000048   0x....             LDR.N    R0,??DataTable21_11
   \   0000004A   0x.... 0x....      BL       assert_failed
    267          									//此处提示警告，但是安全的……
    268          	
    269              addr.DW = (uint32)((sectorNo<<11) + offset);		//计算地址
   \                     ??flash_write_buf_2: (+1)
   \   0000004E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000050   0x02F8             LSLS     R0,R7,#+11
   \   00000052   0xFA10 0xF086      UXTAH    R0,R0,R6
   \   00000056   0x9000             STR      R0,[SP, #+0]
    270          	
    271              // 设置写入命令
    272              FTFL_FCCOB0 = PGM4;
   \   00000058   0x....             LDR.N    R0,??DataTable21_3  ;; 0x40020007
   \   0000005A   0x2106             MOVS     R1,#+6
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    273          
    274              for(size=0; size<cnt; size+=4, addr.DW+=4, buf+=4)
   \   0000005E   0x2600             MOVS     R6,#+0
   \   00000060   0xE004             B.N      ??flash_write_buf_3
   \                     ??flash_write_buf_4: (+1)
   \   00000062   0x1D36             ADDS     R6,R6,#+4
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x1D00             ADDS     R0,R0,#+4
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x1D2D             ADDS     R5,R5,#+4
   \                     ??flash_write_buf_3: (+1)
   \   0000006C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006E   0x42A6             CMP      R6,R4
   \   00000070   0xD21D             BCS.N    ??flash_write_buf_5
    275              {
    276                  
    277                  FTFL_FCCOB1 = addr.B[2];						// 设置目标地址
   \   00000072   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000076   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40020006
   \   00000078   0x7008             STRB     R0,[R1, #+0]
    278                  FTFL_FCCOB2 = addr.B[1];
   \   0000007A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000007E   0x....             LDR.N    R1,??DataTable21_5  ;; 0x40020005
   \   00000080   0x7008             STRB     R0,[R1, #+0]
    279                  FTFL_FCCOB3 = addr.B[0];
   \   00000082   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40020004
   \   00000084   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000088   0x7001             STRB     R1,[R0, #+0]
    280           
    281                  FTFL_FCCOB4 = buf[3];							// 拷贝数据
   \   0000008A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000008C   0x....             LDR.N    R1,??DataTable21_7  ;; 0x4002000b
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    282                  FTFL_FCCOB5 = buf[2];
   \   00000090   0x78A8             LDRB     R0,[R5, #+2]
   \   00000092   0x....             LDR.N    R1,??DataTable21_8  ;; 0x4002000a
   \   00000094   0x7008             STRB     R0,[R1, #+0]
    283                  FTFL_FCCOB6 = buf[1];
   \   00000096   0x7868             LDRB     R0,[R5, #+1]
   \   00000098   0x....             LDR.N    R1,??DataTable21_9  ;; 0x40020009
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
    284                  FTFL_FCCOB7 = buf[0];
   \   0000009C   0x....             LDR.N    R0,??DataTable21_10  ;; 0x40020008
   \   0000009E   0x7829             LDRB     R1,[R5, #+0]
   \   000000A0   0x7001             STRB     R1,[R0, #+0]
    285                  
    286                  if(1 == flash_cmd_launch()) 
   \   000000A2   0x.... 0x....      BL       flash_cmd_launch
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD1DB             BNE.N    ??flash_write_buf_4
    287                      return 2;  									//写入命令错误
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0xE000             B.N      ??flash_write_buf_6
    288              }
    289              
    290              return 0;  //成功执行
   \                     ??flash_write_buf_5: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??flash_write_buf_6: (+1)
   \   000000B0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    291          }
    292          
    293          /*************************************************************************
    294          *  函数名称：flash_write_buf32
    295          *  功能说明：擦除指定flash扇区
    296          *  参数说明：sectorNo：目标扇区号 （K60N512实际使用0~255）
    297          *            offset:写入扇区内部偏移地址（0~2043）     
    298          *            cnt：写入字节数目（0~2043）
    299          *            buf：源数据缓冲区首地址
    300          *  函数返回：函数执行状态：0=正常；非0=异常。
    301          *  修改时间：2012-6-11    已测试
    302          *  备    注：flash写入操作
    303          *************************************************************************/

   \                                 In section .textrw, align 2, keep-with-next
    304          __RAMFUN uint8 flash_write_buf32(uint16 sectorNo,uint16 offset,uint16 cnt,uint32 buf[])
    305          {
   \                     flash_write_buf32: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
    306              uint32 size;
    307              Dtype	Data;
    308              Dtype	addr;	
    309          
    310              ASSERT(offset%4 == 0);			//偏移量必须为4的倍数
   \   0000000C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xFB97 0xF1F0      SDIV     R1,R7,R0
   \   00000014   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD004             BEQ.N    ??flash_write_buf32_0
   \   0000001C   0xF44F 0x719B      MOV      R1,#+310
   \   00000020   0x....             LDR.N    R0,??DataTable21_11
   \   00000022   0x.... 0x....      BL       assert_failed
    311                                                                              //此处提示警告，但是安全的……
    312              ASSERT(offset <= 0x800);		//扇区大小为2K，即偏移量必须不大于 0x800
   \                     ??flash_write_buf32_0: (+1)
   \   00000026   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000028   0xF5B7 0x6F00      CMP      R7,#+2048
   \   0000002C   0xDD04             BLE.N    ??flash_write_buf32_1
   \   0000002E   0xF44F 0x719C      MOV      R1,#+312
   \   00000032   0x....             LDR.N    R0,??DataTable21_11
   \   00000034   0x.... 0x....      BL       assert_failed
    313                                                                              //此处提示警告，但是安全的……
    314              ASSERT((offset + cnt) <= 0x800);        //只能在当前块操作
   \                     ??flash_write_buf32_1: (+1)
   \   00000038   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003A   0xFA14 0xF087      UXTAH    R0,R4,R7
   \   0000003E   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000042   0xDD04             BLE.N    ??flash_write_buf32_2
   \   00000044   0xF44F 0x719D      MOV      R1,#+314
   \   00000048   0x....             LDR.N    R0,??DataTable21_11
   \   0000004A   0x.... 0x....      BL       assert_failed
    315                                                                              //此处提示警告，但是安全的……
    316          	
    317              addr.DW = (uint32)((sectorNo<<11) + offset);		//计算地址
   \                     ??flash_write_buf32_2: (+1)
   \   0000004E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000050   0x02F0             LSLS     R0,R6,#+11
   \   00000052   0xFA10 0xF087      UXTAH    R0,R0,R7
   \   00000056   0x9000             STR      R0,[SP, #+0]
    318              // 设置写入命令
    319              FTFL_FCCOB0 = PGM4;
   \   00000058   0x....             LDR.N    R0,??DataTable21_3  ;; 0x40020007
   \   0000005A   0x2106             MOVS     R1,#+6
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    320          
    321              for(size=0; size<cnt; size+=1, addr.DW+=4)
   \   0000005E   0x2600             MOVS     R6,#+0
   \   00000060   0xE003             B.N      ??flash_write_buf32_3
   \                     ??flash_write_buf32_4: (+1)
   \   00000062   0x1C76             ADDS     R6,R6,#+1
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x1D00             ADDS     R0,R0,#+4
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \                     ??flash_write_buf32_3: (+1)
   \   0000006A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006C   0x42A6             CMP      R6,R4
   \   0000006E   0xD224             BCS.N    ??flash_write_buf32_5
    322              {
    323                  Data.DW	= buf[size];	
   \   00000070   0xF855 0x0026      LDR      R0,[R5, R6, LSL #+2]
   \   00000074   0x9001             STR      R0,[SP, #+4]
    324                  FTFL_FCCOB1 = addr.B[2];						// 设置目标地址
   \   00000076   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000007A   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40020006
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
    325                  FTFL_FCCOB2 = addr.B[1];
   \   0000007E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000082   0x....             LDR.N    R1,??DataTable21_5  ;; 0x40020005
   \   00000084   0x7008             STRB     R0,[R1, #+0]
    326                  FTFL_FCCOB3 = addr.B[0];
   \   00000086   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40020004
   \   00000088   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000008C   0x7001             STRB     R1,[R0, #+0]
    327          
    328          	FTFL_FCCOB4 = Data.B[3];        // 设置写入数据
   \   0000008E   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000092   0x....             LDR.N    R1,??DataTable21_7  ;; 0x4002000b
   \   00000094   0x7008             STRB     R0,[R1, #+0]
    329          	FTFL_FCCOB5 = Data.B[2];
   \   00000096   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000009A   0x....             LDR.N    R1,??DataTable21_8  ;; 0x4002000a
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
    330          	FTFL_FCCOB6 = Data.B[1];
   \   0000009E   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   000000A2   0x....             LDR.N    R1,??DataTable21_9  ;; 0x40020009
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    331          	FTFL_FCCOB7 = Data.B[0];
   \   000000A6   0x....             LDR.N    R0,??DataTable21_10  ;; 0x40020008
   \   000000A8   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000000AC   0x7001             STRB     R1,[R0, #+0]
    332                  
    333                  
    334                  if(1 == flash_cmd_launch()) 
   \   000000AE   0x.... 0x....      BL       flash_cmd_launch
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD1D5             BNE.N    ??flash_write_buf32_4
    335                      return 2;  									//写入命令错误
   \   000000B6   0x2002             MOVS     R0,#+2
   \   000000B8   0xE000             B.N      ??flash_write_buf32_6
    336              }
    337              
    338              return 0;  //成功执行
   \                     ??flash_write_buf32_5: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??flash_write_buf32_6: (+1)
   \   000000BC   0xBDFE             POP      {R1-R7,PC}       ;; return
    339          }
    340          
    341          /***************************************************
    342          ** 函数名称: void FlashDataInit() 
    343          ** 功能描述: 初始化flash数据
    344          **  入  口 ：
    345          **  出  口 ：
    346          **  说  明 : 如果flash中没有数据就把变量初始值写入，
    347                       否则保持原有值不变量
    348                       主要作用是单片机每一次下载程序后会把所
    349                       有flash擦除，所以要写一次初始值
    350          ****************************************************/ 

   \                                 In section .text, align 2, keep-with-next
    351          void FlashDataInit() 
    352          {
   \                     FlashDataInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    353               uint8      i = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    354               uint32	data32;
    355               
    356               //将用户数据放回到flash
    357               SetUserFlash(1); 
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       SetUserFlash
    358                   
    359               for(i=0;i<FLASH_BUFFER_MAX;i++) 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
   \   0000000E   0xE00C             B.N      ??FlashDataInit_0
    360               {
    361                  data32 = flash_read(SECTOR_NUM,i*4,uint32);	//读取4字节
   \                     ??FlashDataInit_1: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x00A0             LSLS     R0,R4,#+2
   \   00000014   0xF510 0x307E      ADDS     R0,R0,#+260096
   \   00000018   0x6800             LDR      R0,[R0, #+0]
    362                  if(data32 != 0xFFFFFFFF)//有数据
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD003             BEQ.N    ??FlashDataInit_2
    363                       FlashData[i] = data32;
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x....             LDR.N    R1,??DataTable3
   \   00000024   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    364               }
   \                     ??FlashDataInit_2: (+1)
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \                     ??FlashDataInit_0: (+1)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C28             CMP      R4,#+40
   \   0000002E   0xDBEF             BLT.N    ??FlashDataInit_1
    365               flash_erase_sector(SECTOR_NUM);		//擦除扇区
   \   00000030   0x207F             MOVS     R0,#+127
   \   00000032   0x.... 0x....      BL       flash_erase_sector
    366               flash_write_buf32(SECTOR_NUM,0,FLASH_BUFFER_MAX,FlashData);
   \   00000036   0x....             LDR.N    R3,??DataTable3
   \   00000038   0x2228             MOVS     R2,#+40
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x207F             MOVS     R0,#+127
   \   0000003E   0x.... 0x....      BL       flash_write_buf32
    367          }
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    368          /***************************************************
    369          ** 函数名称: void ReadFlashData() 
    370          ** 功能描述: 读取flash中数据并写回到用户变量中
    371          **  入  口 ：
    372          **  出  口 ：
    373          **  说  明 : 
    374          ****************************************************/

   \                                 In section .text, align 2, keep-with-next
    375          void ReadFlashData() 
    376          {
   \                     ReadFlashData: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    377               uint8      i = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    378               uint32	data32;
    379               
    380               for(i=0;i<FLASH_BUFFER_MAX;i++) 
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0xE009             B.N      ??ReadFlashData_0
    381               {
    382                  data32 = flash_read(SECTOR_NUM,i*4,uint32);	//读取4字节         
   \                     ??ReadFlashData_1: (+1)
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x0081             LSLS     R1,R0,#+2
   \   0000000E   0xF511 0x317E      ADDS     R1,R1,#+260096
   \   00000012   0x6809             LDR      R1,[R1, #+0]
    383                  FlashData[i] = data32;
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x....             LDR.N    R2,??DataTable3
   \   00000018   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    384               }
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \                     ??ReadFlashData_0: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2828             CMP      R0,#+40
   \   00000022   0xDBF2             BLT.N    ??ReadFlashData_1
    385               //将flash缓冲区中数据放到到用户变量中
    386               SetUserFlash(0) ;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       SetUserFlash
    387          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    388          
    389          /***************************************************
    390          ** 函数名称: void WriteFlashData() 
    391          ** 功能描述: 把用户变量中数据写回到flash中
    392          **  入  口 ：
    393          **  出  口 ：
    394          **  说  明 : 
    395          ****************************************************/

   \                                 In section .text, align 2, keep-with-next
    396          void WriteFlashData() 
    397          {
   \                     WriteFlashData: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    398               //将用户数据放回到flash
    399               SetUserFlash(1); 
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       SetUserFlash
    400               flash_erase_sector(SECTOR_NUM);		//擦除扇区
   \   00000008   0x207F             MOVS     R0,#+127
   \   0000000A   0x.... 0x....      BL       flash_erase_sector
    401               flash_write_buf32(SECTOR_NUM,0,FLASH_BUFFER_MAX,FlashData);
   \   0000000E   0x....             LDR.N    R3,??DataTable3
   \   00000010   0x2228             MOVS     R2,#+40
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x207F             MOVS     R0,#+127
   \   00000016   0x.... 0x....      BL       flash_write_buf32
    402          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x4001F004         DC32     0x4001f004

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x4001F008         DC32     0x4001f008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x40020007         DC32     0x40020007

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x40020006         DC32     0x40020006

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x40020005         DC32     0x40020005

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x4002000B         DC32     0x4002000b

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x4002000A         DC32     0x4002000a

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x40020009         DC32     0x40020009

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x40020008         DC32     0x40020008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x........         DC32     `?<Constant "C:\\\\Users\\\\Administrato...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     FlashData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     speed_duty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     steer_dp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     steer_dd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     line_first

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     line_second

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     line_third

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     line_fourth

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     k_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     k_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     k_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     k_4

   \                                 In section .rodata, align 4
   \                     `?<Constant "C:\\\\Users\\\\Administrato...">`:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x41          DC8 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H, 73H
   \              0x64 0x6D    
   \              0x69 0x6E    
   \              0x69 0x73    
   \   00000010   0x74 0x72          DC8 74H, 72H, 61H, 74H, 6FH, 72H, 5CH, 44H
   \              0x61 0x74    
   \              0x6F 0x72    
   \              0x5C 0x44    
   \   00000018   0x65 0x73          DC8 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH, 4DH
   \              0x6B 0x74    
   \              0x6F 0x70    
   \              0x5C 0x4D    
   \   00000020   0x50 0x55          DC8 50H, 55H, 36H, 30H, 35H, 30H, 38H, 2EH
   \              0x36 0x30    
   \              0x35 0x30    
   \              0x38 0x2E    
   \   00000028   0x31 0x32          DC8 31H, 32H, 5CH, 73H, 72H, 63H, 5CH, 64H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x64    
   \   00000030   0x72 0x69          DC8 72H, 69H, 76H, 65H, 72H, 73H, 5CH, 46H
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x5C 0x46    
   \   00000038   0x6C 0x61          DC8 6CH, 61H, 73H, 68H, 5CH, 66H, 6CH, 61H
   \              0x73 0x68    
   \              0x5C 0x66    
   \              0x6C 0x61    
   \   00000040   0x73 0x68          DC8 73H, 68H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    403          
    404          //===========================example=================================================
    405          /*
    406          #define	SECTOR_NUM	127			//尽量用最后面的扇区，确保安全
    407          void  main(void)
    408          {
    409          	uint32	data32;
    410          	uint16	data16;
    411          	uint8	data8;
    412          	
    413          	flash_init();										//初始化flash
    414          	
    415          	flash_erase_sector(SECTOR_NUM);						//擦除扇区
    416          														//写入flash数据前，需要先擦除对应的扇区(不然数据会乱)      
    417                  if( 0==flash_write(SECTOR_NUM,4,0x90ABCDEF) )		//写入数据到扇区，偏移地址为0，必须一次写入4字节													//if是用来检测是否写入成功，写入成功了就读取
    418          	{
    419          		data32 = 	flash_read(SECTOR_NUM,4,uint32);	//读取4字节
    420          		uart0Printf("一次读取32位的数据为：0x%08X\n",data32);
    421          		
    422          		data16 =	flash_read(SECTOR_NUM,4,uint16);	//读取2字节
    423          		uart0Printf("一次读取16位的数据为：0x%04X\n",data16);
    424          		
    425          		data8  =	flash_read(SECTOR_NUM,4,uint8);		//读取1字节
    426          		uart0Printf("一次读取8位的数据为：0x%02X\n",data8);
    427                          
    428                          data8  =	flash_read(SECTOR_NUM,5,uint8);		//读取1字节
    429          		uart0Printf("一次读取8位的数据为：0x%02X\n",data8);
    430                          
    431                          data8  =	flash_read(SECTOR_NUM,6,uint8);		//读取1字节
    432          		uart0Printf("一次读取8位的数据为：0x%02X\n",data8);
    433                          
    434                          data8  =	flash_read(SECTOR_NUM,7,uint8);		//读取1字节
    435          		uart0Printf("一次读取8位的数据为：0x%02X\n",data8);
    436          	}
    437          	
    438              while(1);
    439          }
    440          */
    441          //==========================================================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FlashDataInit
         8   -> SetUserFlash
         8   -> flash_erase_sector
         8   -> flash_write_buf32
       8   ReadFlashData
         8   -> SetUserFlash
       0   SetUserFlash
       8   WriteFlashData
         8   -> SetUserFlash
         8   -> flash_erase_sector
         8   -> flash_write_buf32
       0   flash_cmd_launch
      16   flash_erase_sector
        16   -> flash_cmd_launch
       0   flash_init
      24   flash_write
        24   -> assert_failed
        24   -> flash_cmd_launch
      24   flash_write_buf
        24   -> assert_failed
        24   -> flash_cmd_launch
      32   flash_write_buf32
        32   -> assert_failed
        32   -> flash_cmd_launch


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      72  ?<Constant "C:\\Users\\Administrato...">
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     160  FlashData
      68  FlashDataInit
      44  ReadFlashData
     208  SetUserFlash
      28  WriteFlashData
      32  flash_cmd_launch
     124  flash_erase_sector
      40  flash_init
     138  flash_write
     178  flash_write_buf
     190  flash_write_buf32

 
 160 bytes in section .bss
  72 bytes in section .rodata
 400 bytes in section .text
 750 bytes in section .textrw
 
 1 150 bytes of CODE  memory
    72 bytes of CONST memory
   160 bytes of DATA  memory

Errors: none
Warnings: 16

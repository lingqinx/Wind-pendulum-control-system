###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     22/Dec/2013  00:55:24 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\src\drivers\mcg\mcg.c                              #
#    Command line =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\src\drivers\mcg\mcg.c -lCN                         #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\List\ -lB                      #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\List\ -o                       #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\Obj\ --no_cse --no_unroll      #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "E:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\Users\Administrator\Desktop\杨向军的K60模板 #
#                    _只有基本IO操作\build\gpio_demo\..\ -I                   #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\common\ -I               #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\cpu\ -I                  #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\ -I              #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\gpio\ -I         #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\wdog\ -I         #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\mcg\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\uart\ -I         #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\lptmr\ -I        #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\fun\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\led\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\i2c\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\MMA845x\ -I      #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\motor\ -I        #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\pit\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\steer\ -I        #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\ftm\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\DIPswitch\ -I    #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\dma\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\platforms\ -I            #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\projects\ -I             #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\projects\gpio_demo\ -Ol  #
#    List file    =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\List\mcg.lst                   #
#    Object file  =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\Obj\mcg.o                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本IO操作\src\drivers\mcg\mcg.c
      1          /*
      2          ************************************************************************
      3          *                北京邮电大学 K60 学习例程                                        
      4          * 文件名 :[mcg.c] 
      5          * 描  述 ：工作时钟模式设置，锁相环
      6          * 原创   ：野火嵌入式开发工作室
      7          *设计改进：snowwolf
      8          *  Email ：snowwolf2012@qq.com
      9          *最后更新：2012-04-03
     10          * 说  明 ：
     11          ***********************************************************************
     12          */
     13          #include "common.h"
     14          #include "mcg.h"
     15          
     16          //时钟参数，便于外部调用
     17          extern u32 core_clk_khz;
     18          extern u32 core_clk_mhz;
     19          extern u32 bus_clk_khz;
     20          
     21          //时钟分频因子

   \                                 In section .data, align 4
     22          struct mcg_div mcg_div = { PRDIV , VDIV , CORE_DIV , BUS_DIV , FLEX_DIV , FLASH_DIV }; //定义的同时，初始化
   \                     mcg_div:
   \   00000000   0x0B 0x1F          DC8 11, 31, 0, 0, 0, 9, 0, 0
   \              0x00 0x00    
   \              0x00 0x09    
   \              0x00 0x00    
     23          
     24          
     25          /*
     26          ************************************************************************
     27          *  函数名称：pll_init
     28          *  功能说明：锁相环函数，用于设定频率。
     29          *  参数说明：crystal_val 晶体选项，这里没用到
     30          *  函数返回：无
     31          *  修改时间：2012-1-20
     32          *  备    注：根据 全局变量 mcg_div 保存的分频因子来分频
     33          ************************************************************************
     34          */

   \                                 In section .text, align 4, keep-with-next
     35          unsigned char pll_init(clk_option opt)
     36          {
   \                     pll_init:
   \   00000000   0xB510             PUSH     {R4,LR}
     37              unsigned char pll_freq;
     38          
     39              if(opt  != PLLUSR ) //自定义模式，直接加载全局变量mcg_div的值
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xF000 0x8105      BEQ.W    ??pll_init_0
     40              {
     41                  //设置MCG时钟
     42                  //mcg_div.prdiv 为12~24之间
     43                  switch(opt)
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x0001             MOVS     R1,R0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD01E             BEQ.N    ??pll_init_1
   \   00000012   0x2932             CMP      R1,#+50
   \   00000014   0xD02C             BEQ.N    ??pll_init_2
   \   00000016   0x2960             CMP      R1,#+96
   \   00000018   0xD031             BEQ.N    ??pll_init_3
   \   0000001A   0x2964             CMP      R1,#+100
   \   0000001C   0xD036             BEQ.N    ??pll_init_4
   \   0000001E   0x296E             CMP      R1,#+110
   \   00000020   0xD03B             BEQ.N    ??pll_init_5
   \   00000022   0x2978             CMP      R1,#+120
   \   00000024   0xD040             BEQ.N    ??pll_init_6
   \   00000026   0x297D             CMP      R1,#+125
   \   00000028   0xD045             BEQ.N    ??pll_init_7
   \   0000002A   0x2982             CMP      R1,#+130
   \   0000002C   0xD04A             BEQ.N    ??pll_init_8
   \   0000002E   0x298C             CMP      R1,#+140
   \   00000030   0xD04F             BEQ.N    ??pll_init_9
   \   00000032   0x2996             CMP      R1,#+150
   \   00000034   0xD054             BEQ.N    ??pll_init_10
   \   00000036   0x29A0             CMP      R1,#+160
   \   00000038   0xD059             BEQ.N    ??pll_init_11
   \   0000003A   0x29AA             CMP      R1,#+170
   \   0000003C   0xD05E             BEQ.N    ??pll_init_12
   \   0000003E   0x29B4             CMP      R1,#+180
   \   00000040   0xD063             BEQ.N    ??pll_init_13
   \   00000042   0x29C8             CMP      R1,#+200
   \   00000044   0xD068             BEQ.N    ??pll_init_14
   \   00000046   0x29E1             CMP      R1,#+225
   \   00000048   0xD06D             BEQ.N    ??pll_init_15
   \   0000004A   0x29FA             CMP      R1,#+250
   \   0000004C   0xD072             BEQ.N    ??pll_init_16
   \   0000004E   0xE078             B.N      ??pll_init_17
     44                  {
     45                  case PLL48:
     46                      mcg_div.prdiv       =24;
   \                     ??pll_init_1:
   \   00000050   0x499E             LDR.N    R1,??pll_init_18
   \   00000052   0x2218             MOVS     R2,#+24
   \   00000054   0x700A             STRB     R2,[R1, #+0]
     47                      mcg_div.vdiv        =0;
   \   00000056   0x499D             LDR.N    R1,??pll_init_18
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x704A             STRB     R2,[R1, #+1]
     48                      break;
     49                  case PLL50:
     50                      mcg_div.prdiv       =24;
     51                      mcg_div.vdiv        =1;
     52                      break;
     53                  case PLL96:
     54                      mcg_div.prdiv       =24;
     55                      mcg_div.vdiv        =24;
     56                      break;
     57                  case PLL100:
     58                      mcg_div.prdiv       =24;
     59                      mcg_div.vdiv        =26;
     60                      break;
     61                  case PLL110:
     62                      mcg_div.prdiv       =24;
     63                      mcg_div.vdiv        =31;
     64                      break;
     65                  case PLL120:
     66                      mcg_div.prdiv       =19;
     67                      mcg_div.vdiv        =24;
     68                      break;
     69                  case PLL125:
     70                      mcg_div.prdiv       =19;
     71                      mcg_div.vdiv        =26;
     72                      break;
     73                  case PLL130:
     74                      mcg_div.prdiv       =19;
     75                      mcg_div.vdiv        =28;
     76                      break;
     77                  case PLL140:
     78                      mcg_div.prdiv       =14;
     79                      mcg_div.vdiv        =18;
     80                      break;
     81                  case PLL150:
     82                      mcg_div.prdiv       =14;
     83                      mcg_div.vdiv        =21;
     84                      break;
     85                  case PLL160:
     86                      mcg_div.prdiv       =14;
     87                      mcg_div.vdiv        =24;
     88                      break;
     89                  case PLL170:
     90                      mcg_div.prdiv       =14;
     91                      mcg_div.vdiv        =27;
     92                      break;
     93                  case PLL180:
     94                      mcg_div.prdiv       =14;
     95                      mcg_div.vdiv        =30;
     96                      break;
     97                  case PLL200:
     98                      mcg_div.prdiv       =12;
     99                      mcg_div.vdiv        =28;
    100                      break;
    101                  case PLL225: //绝大部分芯片都成超到这个程度
    102                      mcg_div.prdiv       =11;
    103                      mcg_div.vdiv        =30;
    104                      break;
    105                  case PLL250: //不同芯片，不同板子，超频能力不一样，不一定全部都能超到这个水平
    106                      mcg_div.prdiv       =10;
    107                      mcg_div.vdiv        =31;
    108                      break;
    109                  default:
    110                      return pll_init(PLL100);        //这情况不会发生。
    111                  }
    112          
    113                  //设置分频
    114                  mcg_div.core_div    = 0;           // core = MCG
   \                     ??pll_init_19:
   \   0000005C   0x499B             LDR.N    R1,??pll_init_18
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x708A             STRB     R2,[R1, #+2]
    115          
    116                  /* 这里提示警告，但是安全的，是为了安全才故意添加进去 */
    117                  if     (opt <= 1*MAX_BUS_CLK)   mcg_div.bus_div = 0;      // bus  = MCG
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x2833             CMP      R0,#+51
   \   00000066   0xD270             BCS.N    ??pll_init_20
   \   00000068   0x4998             LDR.N    R1,??pll_init_18
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x70CA             STRB     R2,[R1, #+3]
   \   0000006E   0xE084             B.N      ??pll_init_21
   \                     ??pll_init_2:
   \   00000070   0x4996             LDR.N    R1,??pll_init_18
   \   00000072   0x2218             MOVS     R2,#+24
   \   00000074   0x700A             STRB     R2,[R1, #+0]
   \   00000076   0x4995             LDR.N    R1,??pll_init_18
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0x704A             STRB     R2,[R1, #+1]
   \   0000007C   0xE7EE             B.N      ??pll_init_19
   \                     ??pll_init_3:
   \   0000007E   0x4993             LDR.N    R1,??pll_init_18
   \   00000080   0x2218             MOVS     R2,#+24
   \   00000082   0x700A             STRB     R2,[R1, #+0]
   \   00000084   0x4991             LDR.N    R1,??pll_init_18
   \   00000086   0x2218             MOVS     R2,#+24
   \   00000088   0x704A             STRB     R2,[R1, #+1]
   \   0000008A   0xE7E7             B.N      ??pll_init_19
   \                     ??pll_init_4:
   \   0000008C   0x498F             LDR.N    R1,??pll_init_18
   \   0000008E   0x2218             MOVS     R2,#+24
   \   00000090   0x700A             STRB     R2,[R1, #+0]
   \   00000092   0x498E             LDR.N    R1,??pll_init_18
   \   00000094   0x221A             MOVS     R2,#+26
   \   00000096   0x704A             STRB     R2,[R1, #+1]
   \   00000098   0xE7E0             B.N      ??pll_init_19
   \                     ??pll_init_5:
   \   0000009A   0x498C             LDR.N    R1,??pll_init_18
   \   0000009C   0x2218             MOVS     R2,#+24
   \   0000009E   0x700A             STRB     R2,[R1, #+0]
   \   000000A0   0x498A             LDR.N    R1,??pll_init_18
   \   000000A2   0x221F             MOVS     R2,#+31
   \   000000A4   0x704A             STRB     R2,[R1, #+1]
   \   000000A6   0xE7D9             B.N      ??pll_init_19
   \                     ??pll_init_6:
   \   000000A8   0x4988             LDR.N    R1,??pll_init_18
   \   000000AA   0x2213             MOVS     R2,#+19
   \   000000AC   0x700A             STRB     R2,[R1, #+0]
   \   000000AE   0x4987             LDR.N    R1,??pll_init_18
   \   000000B0   0x2218             MOVS     R2,#+24
   \   000000B2   0x704A             STRB     R2,[R1, #+1]
   \   000000B4   0xE7D2             B.N      ??pll_init_19
   \                     ??pll_init_7:
   \   000000B6   0x4985             LDR.N    R1,??pll_init_18
   \   000000B8   0x2213             MOVS     R2,#+19
   \   000000BA   0x700A             STRB     R2,[R1, #+0]
   \   000000BC   0x4983             LDR.N    R1,??pll_init_18
   \   000000BE   0x221A             MOVS     R2,#+26
   \   000000C0   0x704A             STRB     R2,[R1, #+1]
   \   000000C2   0xE7CB             B.N      ??pll_init_19
   \                     ??pll_init_8:
   \   000000C4   0x4981             LDR.N    R1,??pll_init_18
   \   000000C6   0x2213             MOVS     R2,#+19
   \   000000C8   0x700A             STRB     R2,[R1, #+0]
   \   000000CA   0x4980             LDR.N    R1,??pll_init_18
   \   000000CC   0x221C             MOVS     R2,#+28
   \   000000CE   0x704A             STRB     R2,[R1, #+1]
   \   000000D0   0xE7C4             B.N      ??pll_init_19
   \                     ??pll_init_9:
   \   000000D2   0x497E             LDR.N    R1,??pll_init_18
   \   000000D4   0x220E             MOVS     R2,#+14
   \   000000D6   0x700A             STRB     R2,[R1, #+0]
   \   000000D8   0x497C             LDR.N    R1,??pll_init_18
   \   000000DA   0x2212             MOVS     R2,#+18
   \   000000DC   0x704A             STRB     R2,[R1, #+1]
   \   000000DE   0xE7BD             B.N      ??pll_init_19
   \                     ??pll_init_10:
   \   000000E0   0x497A             LDR.N    R1,??pll_init_18
   \   000000E2   0x220E             MOVS     R2,#+14
   \   000000E4   0x700A             STRB     R2,[R1, #+0]
   \   000000E6   0x4979             LDR.N    R1,??pll_init_18
   \   000000E8   0x2215             MOVS     R2,#+21
   \   000000EA   0x704A             STRB     R2,[R1, #+1]
   \   000000EC   0xE7B6             B.N      ??pll_init_19
   \                     ??pll_init_11:
   \   000000EE   0x4977             LDR.N    R1,??pll_init_18
   \   000000F0   0x220E             MOVS     R2,#+14
   \   000000F2   0x700A             STRB     R2,[R1, #+0]
   \   000000F4   0x4975             LDR.N    R1,??pll_init_18
   \   000000F6   0x2218             MOVS     R2,#+24
   \   000000F8   0x704A             STRB     R2,[R1, #+1]
   \   000000FA   0xE7AF             B.N      ??pll_init_19
   \                     ??pll_init_12:
   \   000000FC   0x4973             LDR.N    R1,??pll_init_18
   \   000000FE   0x220E             MOVS     R2,#+14
   \   00000100   0x700A             STRB     R2,[R1, #+0]
   \   00000102   0x4972             LDR.N    R1,??pll_init_18
   \   00000104   0x221B             MOVS     R2,#+27
   \   00000106   0x704A             STRB     R2,[R1, #+1]
   \   00000108   0xE7A8             B.N      ??pll_init_19
   \                     ??pll_init_13:
   \   0000010A   0x4970             LDR.N    R1,??pll_init_18
   \   0000010C   0x220E             MOVS     R2,#+14
   \   0000010E   0x700A             STRB     R2,[R1, #+0]
   \   00000110   0x496E             LDR.N    R1,??pll_init_18
   \   00000112   0x221E             MOVS     R2,#+30
   \   00000114   0x704A             STRB     R2,[R1, #+1]
   \   00000116   0xE7A1             B.N      ??pll_init_19
   \                     ??pll_init_14:
   \   00000118   0x496C             LDR.N    R1,??pll_init_18
   \   0000011A   0x220C             MOVS     R2,#+12
   \   0000011C   0x700A             STRB     R2,[R1, #+0]
   \   0000011E   0x496B             LDR.N    R1,??pll_init_18
   \   00000120   0x221C             MOVS     R2,#+28
   \   00000122   0x704A             STRB     R2,[R1, #+1]
   \   00000124   0xE79A             B.N      ??pll_init_19
   \                     ??pll_init_15:
   \   00000126   0x4969             LDR.N    R1,??pll_init_18
   \   00000128   0x220B             MOVS     R2,#+11
   \   0000012A   0x700A             STRB     R2,[R1, #+0]
   \   0000012C   0x4967             LDR.N    R1,??pll_init_18
   \   0000012E   0x221E             MOVS     R2,#+30
   \   00000130   0x704A             STRB     R2,[R1, #+1]
   \   00000132   0xE793             B.N      ??pll_init_19
   \                     ??pll_init_16:
   \   00000134   0x4965             LDR.N    R1,??pll_init_18
   \   00000136   0x220A             MOVS     R2,#+10
   \   00000138   0x700A             STRB     R2,[R1, #+0]
   \   0000013A   0x4964             LDR.N    R1,??pll_init_18
   \   0000013C   0x221F             MOVS     R2,#+31
   \   0000013E   0x704A             STRB     R2,[R1, #+1]
   \   00000140   0xE78C             B.N      ??pll_init_19
   \                     ??pll_init_17:
   \   00000142   0x2064             MOVS     R0,#+100
   \   00000144   0xF7FF 0xFF5C      BL       pll_init
   \   00000148   0xE0BF             B.N      ??pll_init_22
    118                  else if(opt <= 2*MAX_BUS_CLK)   mcg_div.bus_div = 1;      // bus  = MCG/2
   \                     ??pll_init_20:
   \   0000014A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014C   0x2865             CMP      R0,#+101
   \   0000014E   0xD203             BCS.N    ??pll_init_23
   \   00000150   0x495E             LDR.N    R1,??pll_init_18
   \   00000152   0x2201             MOVS     R2,#+1
   \   00000154   0x70CA             STRB     R2,[R1, #+3]
   \   00000156   0xE010             B.N      ??pll_init_21
    119                  else if(opt <= 3*MAX_BUS_CLK)   mcg_div.bus_div = 2;      // bus  = MCG/3
   \                     ??pll_init_23:
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x2897             CMP      R0,#+151
   \   0000015C   0xD203             BCS.N    ??pll_init_24
   \   0000015E   0x495B             LDR.N    R1,??pll_init_18
   \   00000160   0x2202             MOVS     R2,#+2
   \   00000162   0x70CA             STRB     R2,[R1, #+3]
   \   00000164   0xE009             B.N      ??pll_init_21
    120                  else if(opt <= 4*MAX_BUS_CLK)   mcg_div.bus_div = 3;      // bus  = MCG/4    这里提示警告，不过没关系
   \                     ??pll_init_24:
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0x28C9             CMP      R0,#+201
   \   0000016A   0xD203             BCS.N    ??pll_init_25
   \   0000016C   0x4957             LDR.N    R1,??pll_init_18
   \   0000016E   0x2203             MOVS     R2,#+3
   \   00000170   0x70CA             STRB     R2,[R1, #+3]
   \   00000172   0xE002             B.N      ??pll_init_21
    121                  else                            mcg_div.bus_div =15;      // bus  = MCG/16
   \                     ??pll_init_25:
   \   00000174   0x4955             LDR.N    R1,??pll_init_18
   \   00000176   0x220F             MOVS     R2,#+15
   \   00000178   0x70CA             STRB     R2,[R1, #+3]
    122          
    123                  mcg_div.flex_div = mcg_div.bus_div;                       // flex   = bus
   \                     ??pll_init_21:
   \   0000017A   0x4954             LDR.N    R1,??pll_init_18
   \   0000017C   0x4A53             LDR.N    R2,??pll_init_18
   \   0000017E   0x78D2             LDRB     R2,[R2, #+3]
   \   00000180   0x710A             STRB     R2,[R1, #+4]
    124          
    125                  /* 这里提示警告，但是安全的，是为了安全才故意添加进去 */
    126                  if     (opt <= 1*MAX_FLASH_CLK)   mcg_div.flash_div = 0; // flash  = MCG
   \   00000182   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000184   0x281A             CMP      R0,#+26
   \   00000186   0xD203             BCS.N    ??pll_init_26
   \   00000188   0x4850             LDR.N    R0,??pll_init_18
   \   0000018A   0x2100             MOVS     R1,#+0
   \   0000018C   0x7141             STRB     R1,[R0, #+5]
   \   0000018E   0xE041             B.N      ??pll_init_0
    127                  else if(opt <= 2*MAX_FLASH_CLK)   mcg_div.flash_div = 1; // flash  = MCG/2
   \                     ??pll_init_26:
   \   00000190   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000192   0x2833             CMP      R0,#+51
   \   00000194   0xD203             BCS.N    ??pll_init_27
   \   00000196   0x484D             LDR.N    R0,??pll_init_18
   \   00000198   0x2101             MOVS     R1,#+1
   \   0000019A   0x7141             STRB     R1,[R0, #+5]
   \   0000019C   0xE03A             B.N      ??pll_init_0
    128                  else if(opt <= 3*MAX_FLASH_CLK)   mcg_div.flash_div = 2; // flash  = MCG/3
   \                     ??pll_init_27:
   \   0000019E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A0   0x284C             CMP      R0,#+76
   \   000001A2   0xD203             BCS.N    ??pll_init_28
   \   000001A4   0x4849             LDR.N    R0,??pll_init_18
   \   000001A6   0x2102             MOVS     R1,#+2
   \   000001A8   0x7141             STRB     R1,[R0, #+5]
   \   000001AA   0xE033             B.N      ??pll_init_0
    129                  else if(opt <= 4*MAX_FLASH_CLK)   mcg_div.flash_div = 3; // flash  = MCG/4
   \                     ??pll_init_28:
   \   000001AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AE   0x2865             CMP      R0,#+101
   \   000001B0   0xD203             BCS.N    ??pll_init_29
   \   000001B2   0x4846             LDR.N    R0,??pll_init_18
   \   000001B4   0x2103             MOVS     R1,#+3
   \   000001B6   0x7141             STRB     R1,[R0, #+5]
   \   000001B8   0xE02C             B.N      ??pll_init_0
    130                  else if(opt <= 5*MAX_FLASH_CLK)   mcg_div.flash_div = 4; // flash  = MCG/5
   \                     ??pll_init_29:
   \   000001BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BC   0x287E             CMP      R0,#+126
   \   000001BE   0xD203             BCS.N    ??pll_init_30
   \   000001C0   0x4842             LDR.N    R0,??pll_init_18
   \   000001C2   0x2104             MOVS     R1,#+4
   \   000001C4   0x7141             STRB     R1,[R0, #+5]
   \   000001C6   0xE025             B.N      ??pll_init_0
    131                  else if(opt <= 6*MAX_FLASH_CLK)   mcg_div.flash_div = 5; // flash  = MCG/6
   \                     ??pll_init_30:
   \   000001C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CA   0x2897             CMP      R0,#+151
   \   000001CC   0xD203             BCS.N    ??pll_init_31
   \   000001CE   0x483F             LDR.N    R0,??pll_init_18
   \   000001D0   0x2105             MOVS     R1,#+5
   \   000001D2   0x7141             STRB     R1,[R0, #+5]
   \   000001D4   0xE01E             B.N      ??pll_init_0
    132                  else if(opt <= 7*MAX_FLASH_CLK)   mcg_div.flash_div = 6; // flash  = MCG/7
   \                     ??pll_init_31:
   \   000001D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D8   0x28B0             CMP      R0,#+176
   \   000001DA   0xD203             BCS.N    ??pll_init_32
   \   000001DC   0x483B             LDR.N    R0,??pll_init_18
   \   000001DE   0x2106             MOVS     R1,#+6
   \   000001E0   0x7141             STRB     R1,[R0, #+5]
   \   000001E2   0xE017             B.N      ??pll_init_0
    133                  else if(opt <= 8*MAX_FLASH_CLK)   mcg_div.flash_div = 7; // flash  = MCG/8
   \                     ??pll_init_32:
   \   000001E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001E6   0x28C9             CMP      R0,#+201
   \   000001E8   0xD203             BCS.N    ??pll_init_33
   \   000001EA   0x4838             LDR.N    R0,??pll_init_18
   \   000001EC   0x2107             MOVS     R1,#+7
   \   000001EE   0x7141             STRB     R1,[R0, #+5]
   \   000001F0   0xE010             B.N      ??pll_init_0
    134                  else if(opt <= 9*MAX_FLASH_CLK)   mcg_div.flash_div = 8; // flash  = MCG/9     这里提示警告，不过没关系
   \                     ??pll_init_33:
   \   000001F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F4   0x28E2             CMP      R0,#+226
   \   000001F6   0xD203             BCS.N    ??pll_init_34
   \   000001F8   0x4834             LDR.N    R0,??pll_init_18
   \   000001FA   0x2108             MOVS     R1,#+8
   \   000001FC   0x7141             STRB     R1,[R0, #+5]
   \   000001FE   0xE009             B.N      ??pll_init_0
    135                  else if(opt <= 10*MAX_FLASH_CLK)  mcg_div.flash_div = 9; // flash  = MCG/10
   \                     ??pll_init_34:
   \   00000200   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000202   0x28FB             CMP      R0,#+251
   \   00000204   0xD203             BCS.N    ??pll_init_35
   \   00000206   0x4831             LDR.N    R0,??pll_init_18
   \   00000208   0x2109             MOVS     R1,#+9
   \   0000020A   0x7141             STRB     R1,[R0, #+5]
   \   0000020C   0xE002             B.N      ??pll_init_0
    136                  else                              mcg_div.flash_div =15; // flash  = MCG/16
   \                     ??pll_init_35:
   \   0000020E   0x482F             LDR.N    R0,??pll_init_18
   \   00000210   0x210F             MOVS     R1,#+15
   \   00000212   0x7141             STRB     R1,[R0, #+5]
    137          
    138              }
    139              
    140              pll_freq = (u8)(( (u16)50 * (u16)( mcg_div.vdiv + 24 ))/ (u16)( mcg_div.prdiv +1 ) );              //  50/ ( prdiv +1 ) * ( mcg_div.vdiv + 24 )
   \                     ??pll_init_0:
   \   00000214   0x482D             LDR.N    R0,??pll_init_18
   \   00000216   0x7840             LDRB     R0,[R0, #+1]
   \   00000218   0x3018             ADDS     R0,R0,#+24
   \   0000021A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000021C   0x2132             MOVS     R1,#+50
   \   0000021E   0x4348             MULS     R0,R1,R0
   \   00000220   0x492A             LDR.N    R1,??pll_init_18
   \   00000222   0x7809             LDRB     R1,[R1, #+0]
   \   00000224   0x1C49             ADDS     R1,R1,#+1
   \   00000226   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000228   0xFB90 0xF4F1      SDIV     R4,R0,R1
    141          
    142              //上电复位后，单片机会自动进入 FEI 模式，使用 内部参考时钟
    143              //为了使用外部时钟参考源，我们要先进入 FBE 模式:
    144          #if (defined(K60_CLK) || defined(ASB817))
    145              MCG_C2 = 0;
   \   0000022C   0x4828             LDR.N    R0,??pll_init_18+0x4  ;; 0x40064001
   \   0000022E   0x2100             MOVS     R1,#+0
   \   00000230   0x7001             STRB     R1,[R0, #+0]
    146          #else
    147              // Enable external oscillator, RANGE=2, HGO=1, EREFS=1, LP=0, IRCS=0
    148              MCG_C2 = MCG_C2_RANGE(2) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
    149          #endif
    150          
    151              //初始化晶振后释放锁定状态的振荡器和GPIO
    152              SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   00000232   0x4828             LDR.N    R0,??pll_init_18+0x8  ;; 0x40048034
   \   00000234   0x6800             LDR      R0,[R0, #+0]
   \   00000236   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000023A   0x4926             LDR.N    R1,??pll_init_18+0x8  ;; 0x40048034
   \   0000023C   0x6008             STR      R0,[R1, #+0]
    153              LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   0000023E   0x4826             LDR.N    R0,??pll_init_18+0xC  ;; 0x4007c008
   \   00000240   0x7800             LDRB     R0,[R0, #+0]
   \   00000242   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000246   0x4924             LDR.N    R1,??pll_init_18+0xC  ;; 0x4007c008
   \   00000248   0x7008             STRB     R0,[R1, #+0]
    154          
    155              // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    156              // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    157              MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
   \   0000024A   0x4824             LDR.N    R0,??pll_init_18+0x10  ;; 0x40064000
   \   0000024C   0x2198             MOVS     R1,#+152
   \   0000024E   0x7001             STRB     R1,[R0, #+0]
    158          
    159              /* if we aren't using an osc input we don't need to wait for the osc to init */
    160          #if (!defined(K60_CLK) && !defined(ASB817))
    161              while (!(MCG_S & MCG_S_OSCINIT_MASK)){};   //等待晶振稳定	
    162          #endif
    163          
    164              while (MCG_S & MCG_S_IREFST_MASK){}; // wait for Reference clock Status bit to clear
   \                     ??pll_init_36:
   \   00000250   0x4823             LDR.N    R0,??pll_init_18+0x14  ;; 0x40064006
   \   00000252   0x7800             LDRB     R0,[R0, #+0]
   \   00000254   0x06C0             LSLS     R0,R0,#+27
   \   00000256   0xD4FB             BMI.N    ??pll_init_36
    165          
    166              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // Wait for clock status bits to show clock source is ext ref clk
   \                     ??pll_init_37:
   \   00000258   0x4821             LDR.N    R0,??pll_init_18+0x14  ;; 0x40064006
   \   0000025A   0x7800             LDRB     R0,[R0, #+0]
   \   0000025C   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000260   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000262   0x2802             CMP      R0,#+2
   \   00000264   0xD1F8             BNE.N    ??pll_init_37
    167          
    168              //进入FBE模式  分频后结果必须在 ：2 MHz ~ 4 MHz.
    169              //    n       (n+1)分频   50M/(n+1)       n为12~24之间
    170              MCG_C5 = MCG_C5_PRDIV(mcg_div.prdiv);   // prdiv +1 分频 ：2M
   \   00000266   0x4819             LDR.N    R0,??pll_init_18
   \   00000268   0x7800             LDRB     R0,[R0, #+0]
   \   0000026A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000026E   0x491D             LDR.N    R1,??pll_init_18+0x18  ;; 0x40064004
   \   00000270   0x7008             STRB     R0,[R1, #+0]
    171          
    172              MCG_C6 = 0x0;       // Ensure MCG_C6 is at the reset default of 0. LOLIE disabled, PLL disabled, clk monitor disabled, PLL VCO divider is clear
   \   00000272   0x481D             LDR.N    R0,??pll_init_18+0x1C  ;; 0x40064005
   \   00000274   0x2100             MOVS     R1,#+0
   \   00000276   0x7001             STRB     R1,[R0, #+0]
    173          
    174              // 设置系统分频因子选项
    175              //MCG=PLL, core = MCG/(mcg_div.core_div + 1), bus = MCG/(mcg_div.bus_div + 1),
    176              //FlexBus = MCG/(mcg_div.flex_div + 1), Flash clock= MCG/(mcg_div.flash_div + 1)
    177              set_sys_dividers(mcg_div.core_div,mcg_div.bus_div,mcg_div.flex_div,mcg_div.flash_div);
   \   00000278   0x4814             LDR.N    R0,??pll_init_18
   \   0000027A   0x7943             LDRB     R3,[R0, #+5]
   \   0000027C   0x4813             LDR.N    R0,??pll_init_18
   \   0000027E   0x7902             LDRB     R2,[R0, #+4]
   \   00000280   0x4812             LDR.N    R0,??pll_init_18
   \   00000282   0x78C1             LDRB     R1,[R0, #+3]
   \   00000284   0x4811             LDR.N    R0,??pll_init_18
   \   00000286   0x7880             LDRB     R0,[R0, #+2]
   \   00000288   0x.... 0x....      BL       set_sys_dividers
    178          
    179              // Set the VCO divider and enable the PLL for 48MHz, LOLIE=0, PLLS=1, CME=0, VDIV=0
    180              //   n    (n+24)倍频            n为0~31之间
    181              MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(mcg_div.vdiv) ;  //  mcg_div.vdiv + 1 倍频
   \   0000028C   0x480F             LDR.N    R0,??pll_init_18
   \   0000028E   0x7840             LDRB     R0,[R0, #+1]
   \   00000290   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000294   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000298   0x4913             LDR.N    R1,??pll_init_18+0x1C  ;; 0x40064005
   \   0000029A   0x7008             STRB     R0,[R1, #+0]
    182          
    183              while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
   \                     ??pll_init_38:
   \   0000029C   0x4810             LDR.N    R0,??pll_init_18+0x14  ;; 0x40064006
   \   0000029E   0x7800             LDRB     R0,[R0, #+0]
   \   000002A0   0x0680             LSLS     R0,R0,#+26
   \   000002A2   0xD5FB             BPL.N    ??pll_init_38
    184          
    185              while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
   \                     ??pll_init_39:
   \   000002A4   0x480E             LDR.N    R0,??pll_init_18+0x14  ;; 0x40064006
   \   000002A6   0x7800             LDRB     R0,[R0, #+0]
   \   000002A8   0x0640             LSLS     R0,R0,#+25
   \   000002AA   0xD5FB             BPL.N    ??pll_init_39
    186          
    187              // 现在已经进入了 PBE 模式
    188          
    189              // Transition into PEE by setting CLKS to 0
    190              // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    191              MCG_C1 &= ~MCG_C1_CLKS_MASK;
   \   000002AC   0x480B             LDR.N    R0,??pll_init_18+0x10  ;; 0x40064000
   \   000002AE   0x7800             LDRB     R0,[R0, #+0]
   \   000002B0   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   000002B4   0x4909             LDR.N    R1,??pll_init_18+0x10  ;; 0x40064000
   \   000002B6   0x7008             STRB     R0,[R1, #+0]
    192          
    193              // Wait for clock status bits to update
    194              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
   \                     ??pll_init_40:
   \   000002B8   0x4809             LDR.N    R0,??pll_init_18+0x14  ;; 0x40064006
   \   000002BA   0x7800             LDRB     R0,[R0, #+0]
   \   000002BC   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   000002C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002C2   0x2803             CMP      R0,#+3
   \   000002C4   0xD1F8             BNE.N    ??pll_init_40
    195          
    196              // 现在已经进入了 PEE 模式
    197          
    198              return pll_freq;
   \   000002C6   0x0020             MOVS     R0,R4
   \   000002C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??pll_init_22:
   \   000002CA   0xBD10             POP      {R4,PC}          ;; return
   \                     ??pll_init_18:
   \   000002CC   0x........         DC32     mcg_div
   \   000002D0   0x40064001         DC32     0x40064001
   \   000002D4   0x40048034         DC32     0x40048034
   \   000002D8   0x4007C008         DC32     0x4007c008
   \   000002DC   0x40064000         DC32     0x40064000
   \   000002E0   0x40064006         DC32     0x40064006
   \   000002E4   0x40064004         DC32     0x40064004
   \   000002E8   0x40064005         DC32     0x40064005
    199          } //pll_init
    200          
    201          
    202          /*
    203          ********************************************************************************
    204          ** 函数名: set_sys_dividers                                                 
    205          ** 功  能: 设置系系统分频器                                                  
    206          ** 参  数: 预分频值   							   
    207          ** 返  回: 无                                                               
    208          ** 说  明: 此函数必须放在RAM里执行，否则会产生错误e2448。当FLASH时钟分频改变 
    209          **         时，必须禁止FLASH的预取功能。在时钟分频改变之后，必须延时一小段时
    210          ** 	 间才可以从新使能预取功能。                                        
    211          **        MCG=PLL   core=MCG/(outdiv1+1)               bus=MCG/(outdiv2+1)  
    212          **                  FlexBus=MCG/(outdiv1+1)    Flash clock=MCG/(outdiv1+1)  
    213          ********************************************************************************
    214          */
    215          

   \                                 In section .textrw, align 4, keep-with-next
    216          __ramfunc  void set_sys_dividers(uint32 outdiv1, uint32 outdiv2, uint32 outdiv3, uint32 outdiv4)
    217          {
   \                     set_sys_dividers:
   \   00000000   0xB470             PUSH     {R4-R6}
    218            /*
    219            * This routine must be placed in RAM. It is a workaround for errata e2448.
    220            * Flash prefetch must be disabled when the flash clock divider is changed.
    221            * This cannot be performed while executing out of flash.
    222            * There must be a short delay after the clock dividers are changed before prefetch
    223            * can be re-enabled.
    224            */
    225              uint32 temp_reg;
    226              uint8 i;
    227          
    228              temp_reg = FMC_PFAPR; // store present value of FMC_PFAPR
   \   00000002   0x4C10             LDR.N    R4,??set_sys_dividers_0  ;; 0x4001f000
   \   00000004   0x6824             LDR      R4,[R4, #+0]
    229          
    230              // set M0PFD through M7PFD to 1 to disable prefetch
    231              FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    232                           | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    233                           | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
   \   00000006   0x4D0F             LDR.N    R5,??set_sys_dividers_0  ;; 0x4001f000
   \   00000008   0x682D             LDR      R5,[R5, #+0]
   \   0000000A   0xF455 0x057F      ORRS     R5,R5,#0xFF0000
   \   0000000E   0x4E0D             LDR.N    R6,??set_sys_dividers_0  ;; 0x4001f000
   \   00000010   0x6035             STR      R5,[R6, #+0]
    234          
    235              // set clock dividers to desired value
    236              SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2)
    237                            | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xF011 0x6170      ANDS     R1,R1,#0xF000000
   \   00000018   0xEA51 0x7000      ORRS     R0,R1,R0, LSL #+28
   \   0000001C   0x0511             LSLS     R1,R2,#+20
   \   0000001E   0xF411 0x0170      ANDS     R1,R1,#0xF00000
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x0419             LSLS     R1,R3,#+16
   \   00000026   0xF411 0x2170      ANDS     R1,R1,#0xF0000
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0x4906             LDR.N    R1,??set_sys_dividers_0+0x4  ;; 0x40048044
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    238          
    239              // wait for dividers to change
    240              for (i = 0 ; i < outdiv4 ; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE000             B.N      ??set_sys_dividers_1
   \                     ??set_sys_dividers_2:
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \                     ??set_sys_dividers_1:
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x4298             CMP      R0,R3
   \   0000003A   0xD3FB             BCC.N    ??set_sys_dividers_2
    241              {}
    242          
    243              FMC_PFAPR = temp_reg; // re-store original value of FMC_PFAPR
   \   0000003C   0x4801             LDR.N    R0,??set_sys_dividers_0  ;; 0x4001f000
   \   0000003E   0x6004             STR      R4,[R0, #+0]
    244          
    245              return;
   \   00000040   0xBC70             POP      {R4-R6}
   \   00000042   0x4770             BX       LR               ;; return
   \                     ??set_sys_dividers_0:
   \   00000044   0x4001F000         DC32     0x4001f000
   \   00000048   0x40048044         DC32     0x40048044
    246          } // set_sys_dividers
    247          
    248          
    249          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  pll_init
             8 -> pll_init
             8 -> set_sys_dividers
       12  set_sys_dividers


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  mcg_div
     748  pll_init
      76  set_sys_dividers

 
   8 bytes in section .data
 748 bytes in section .text
  76 bytes in section .textrw
 
 824 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none

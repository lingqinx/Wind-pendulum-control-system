###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     22/Dec/2013  00:55:26 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\src\drivers\lptmr\lptmr.c                          #
#    Command line =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\src\drivers\lptmr\lptmr.c -lCN                     #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\List\ -lB                      #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\List\ -o                       #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\Obj\ --no_cse --no_unroll      #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "E:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\Users\Administrator\Desktop\杨向军的K60模板 #
#                    _只有基本IO操作\build\gpio_demo\..\ -I                   #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\common\ -I               #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\cpu\ -I                  #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\ -I              #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\gpio\ -I         #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\wdog\ -I         #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\mcg\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\uart\ -I         #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\lptmr\ -I        #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\fun\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\led\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\i2c\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\MMA845x\ -I      #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\motor\ -I        #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\pit\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\steer\ -I        #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\ftm\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\DIPswitch\ -I    #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\drivers\dma\ -I          #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\platforms\ -I            #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\projects\ -I             #
#                    C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\..\..\src\projects\gpio_demo\ -Ol  #
#    List file    =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\List\lptmr.lst                 #
#    Object file  =  C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本I #
#                    O操作\build\gpio_demo\RAM\Obj\lptmr.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\杨向军的K60模板_只有基本IO操作\src\drivers\lptmr\lptmr.c
      1          /*
      2          ************************************************************************
      3          *                北京邮电大学 K60 学习例程                                        
      4          * 文件名 :[lptmr.c] 
      5          * 描  述 ：lptmr定功耗定时器，目前只有一个定时器延时函数
      6          * 原创   ：官方例程
      7          *设计改进：snowwolf
      8          *  Email ：snowwolf2012@qq.com
      9          *最后更新：2012-04-03
     10          * 说  明 ：
     11          ***********************************************************************
     12          */
     13          
     14          #include "common.h"
     15          #include "lptmr.h"
     16          #include "fun.h"
     17          
     18          
     19          /*************************************************************************
     20          *  函数名称：lptmr_counter_init
     21          *  功能说明：LPT累加捕捉
     22          *  参数说明：LPT0_ALTn      输入管脚号 ，只能是 LPT0_ALT1、LPT0_ALT2
     23          *            count          产生中断的累加计数值
     24          *            PrescaleValue  延时滤波
     25          *            LPT_CFG        触发方式
     26          *  函数返回：无
     27          *  修改时间：2012-3-14
     28          *  备    注：
     29          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     30          void lptmr_counter_init(LPT0_ALTn altn,u16 count,u8 PrescaleValue,LPT_CFG cfg)
     31          {
   \                     lptmr_counter_init:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001E             MOVS     R6,R3
     32          
     33          	if(PrescaleValue > 0x0f)PrescaleValue=0x0f;
   \   0000000A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000C   0x2F10             CMP      R7,#+16
   \   0000000E   0xD300             BCC.N    ??lptmr_counter_init_0
   \   00000010   0x270F             MOVS     R7,#+15
     34          
     35          	//设置输入管脚
     36                  /* 与外部晶振相接不建议使用
     37          	if(altn==LPT0_ALT1)
     38          	{
     39          		SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;  //打开 PORTA 时钟
     40          		PORTA_PCR19=PORT_PCR_MUX(0x6);      //在PTA19上使用 ALT6
     41          	}
     42          	else 
     43                  */
     44                  if(altn==LPT0_ALT2)
   \                     ??lptmr_counter_init_0:
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xD10A             BNE.N    ??lptmr_counter_init_1
     45          	{
     46          		SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;  //使能 PORTC 时钟
   \   00000018   0x....             LDR.N    R0,??DataTable4  ;; 0x40048038
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000020   0x....             LDR.N    R1,??DataTable4  ;; 0x40048038
   \   00000022   0x6008             STR      R0,[R1, #+0]
     47          		PORTC_PCR5=PORT_PCR_MUX(0x4);       //在PTC5上使用 ALT4
   \   00000024   0x....             LDR.N    R0,??DataTable4_1  ;; 0x4004b014
   \   00000026   0xF44F 0x6180      MOV      R1,#+1024
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   \   0000002C   0xE003             B.N      ??lptmr_counter_init_2
     48          	}
     49          	else                                    //不可能发生事件
     50          	{
     51          		assert_failed(__FILE__, __LINE__);  //设置管脚有误？
   \                     ??lptmr_counter_init_1:
   \   0000002E   0x2133             MOVS     R1,#+51
   \   00000030   0x....             LDR.N    R0,??DataTable4_2
   \   00000032   0x.... 0x....      BL       assert_failed
     52          	}
     53          
     54              /* 开启模块时钟 */
     55              SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK;      //使能LPT模块时钟
   \                     ??lptmr_counter_init_2:
   \   00000036   0x....             LDR.N    R0,??DataTable4  ;; 0x40048038
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003E   0x....             LDR.N    R1,??DataTable4  ;; 0x40048038
   \   00000040   0x6008             STR      R0,[R1, #+0]
     56          
     57              /* 清状态寄存器 */
     58              LPTMR0_CSR=0x00;                        //先关了LPT，这样才能设置时钟分频等
   \   00000042   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6001             STR      R1,[R0, #+0]
     59          
     60              /* 设置累加计数值  */
     61              LPTMR_CMR_REG(LPTMR0_BASE_PTR)  =   LPTMR_CMR_COMPARE(count);                       //设置比较值
   \   00000048   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40040008
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x6005             STR      R5,[R0, #+0]
     62          
     63              /* 时钟选择 */
     64              LPTMR_PSR_REG(LPTMR0_BASE_PTR)  =   LPTMR_PSR_PCS(0x1) | LPTMR_PSR_PBYP_MASK  |  LPTMR_PSR_PRESCALE(PrescaleValue);        //使用 LPO clock 且 bypass glitch filter
   \   0000004E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000050   0x00F8             LSLS     R0,R7,#+3
   \   00000052   0xF010 0x0078      ANDS     R0,R0,#0x78
   \   00000056   0xF050 0x0005      ORRS     R0,R0,#0x5
   \   0000005A   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40040004
   \   0000005C   0x6008             STR      R0,[R1, #+0]
     65          	//                                                        开启和配置脉冲滤波器：2^n个时钟上升沿才识别
     66          
     67              /* 管脚设置、使能中断  */
     68              LPTMR_CSR_REG(LPTMR0_BASE_PTR)  =   LPTMR_CSR_TPS(altn)| LPTMR_CSR_TMS_MASK  | ( cfg ==LPT_Falling ?  LPTMR_CSR_TPP_MASK :   0  )  | LPTMR_CSR_TEN_MASK;
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x2E01             CMP      R6,#+1
   \   00000062   0xD101             BNE.N    ??lptmr_counter_init_3
   \   00000064   0x2008             MOVS     R0,#+8
   \   00000066   0xE000             B.N      ??lptmr_counter_init_4
   \                     ??lptmr_counter_init_3:
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??lptmr_counter_init_4:
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x0121             LSLS     R1,R4,#+4
   \   0000006E   0xF011 0x0130      ANDS     R1,R1,#0x30
   \   00000072   0x4308             ORRS     R0,R0,R1
   \   00000074   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   00000078   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40040000
   \   0000007A   0x6008             STR      R0,[R1, #+0]
     69              //                                       选择输入管脚        选择脉冲计数                                   下降沿       上升沿           使能LPT
     70              // TFC = 0，即计数值等于比较值时，计数值复位
     71          }
   \   0000007C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     72          
     73          /*************************************************************************
     74          *  函数名称：lptmr_irq_EN
     75          *  功能说明：lptmr定时中断使能
     76          *  参数说明：
     77          *  函数返回：无
     78          *  修改时间：2012-3-24
     79          *  备    注：
     80          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     81          void lptmr_irq_EN()
     82          {
   \                     lptmr_irq_EN:
   \   00000000   0xB580             PUSH     {R7,LR}
     83               LPTMR_CSR_REG(LPTMR0_BASE_PTR) |= LPTMR_CSR_TIE_MASK;     //使能 lptmr定时器,并开中断  
   \   00000002   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000000A   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40040000
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     84               enable_irq(LPTMR_irq);	                //开引脚的IRQ中断	
   \   0000000E   0x2055             MOVS     R0,#+85
   \   00000010   0x.... 0x....      BL       enable_irq
     85          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
     86          
     87          /*************************************************************************
     88          *  函数名称：lptmr_irq_DIS
     89          *  功能说明：lptmr定时中断关闭
     90          *  参数说明：
     91          *  函数返回：无
     92          *  修改时间：2012-3-24
     93          *  备    注：
     94          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     95          void lptmr_irq_DIS()
     96          {
   \                     lptmr_irq_DIS:
   \   00000000   0xB580             PUSH     {R7,LR}
     97               LPTMR_CSR_REG(LPTMR0_BASE_PTR) &= ~LPTMR_CSR_TIE_MASK;     //关 lptmr定时器,并关中断  
   \   00000002   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000A   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40040000
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     98               disable_irq(LPTMR_irq);	
   \   0000000E   0x2055             MOVS     R0,#+85
   \   00000010   0x.... 0x....      BL       disable_irq
     99          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void lptmr_counter_clean(void)
    102          {
    103              LPTMR_CSR_REG(LPTMR0_BASE_PTR)  &= ~LPTMR_CSR_TEN_MASK;     //禁用LPT的时候就会自动清计数器的值
   \                     lptmr_counter_clean:
   \   00000000   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0840             LSRS     R0,R0,#+1
   \   00000006   0x0040             LSLS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40040000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    104              LPTMR_CSR_REG(LPTMR0_BASE_PTR)  |=LPTMR_CSR_TEN_MASK;
   \   0000000C   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000014   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40040000
   \   00000016   0x6008             STR      R0,[R1, #+0]
    105          }
   \   00000018   0x4770             BX       LR               ;; return
    106          
    107          
    108          
    109          /*************************************************************************
    110          *  函数名称：time_delay_ms
    111          *  功能说明：延时函数，使用定功耗定时器延时，准确
    112          *  参数说明：ms   延时时间，单位为ms
    113          *  函数返回：无
    114          *  修改时间：2012-1-20
    115          *  备    注：官方例程自带       //使用外部测速不要使用这个函数，影响寄存器配置
    116                                          //不精确延时用delayms()(这个函数也很准的)
    117          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    118          void time_delay_ms(uint32 ms)
    119          {
    120              /* Make sure the clock to the LPTMR is enabled */
    121              SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK;
   \                     time_delay_ms:
   \   00000000   0x....             LDR.N    R1,??DataTable4  ;; 0x40048038
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000008   0x....             LDR.N    R2,??DataTable4  ;; 0x40048038
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    122          
    123              /* Set the compare value to the number of ms to delay */
    124              LPTMR0_CMR = ms;
   \   0000000C   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40040008
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    125          
    126              /* Set up LPTMR to use 1kHz LPO with no prescaler as its clock source */
    127              LPTMR0_PSR = LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK;
   \   00000010   0x....             LDR.N    R0,??DataTable4_5  ;; 0x40040004
   \   00000012   0x2105             MOVS     R1,#+5
   \   00000014   0x6001             STR      R1,[R0, #+0]
    128          
    129              /* Start the timer */
    130              LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
   \   00000016   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001E   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40040000
   \   00000020   0x6008             STR      R0,[R1, #+0]
    131          
    132              /* Wait for counter to reach compare value */
    133              while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK))
   \                     ??time_delay_ms_0:
   \   00000022   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0600             LSLS     R0,R0,#+24
   \   00000028   0xD5FB             BPL.N    ??time_delay_ms_0
    134              {
    135                //uartPrintf("%d\n",LPTMR0_CNR);
    136                //delayms(10);
    137              }
    138          
    139              /* Clear Timer Compare Flag */
    140              LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
   \   0000002A   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40040000
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x0040             LSLS     R0,R0,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40040000
   \   00000034   0x6008             STR      R0,[R1, #+0]
    141          
    142              return;
   \   00000036   0x4770             BX       LR               ;; return
    143          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x4004B014         DC32     0x4004b014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     `?<Constant "C:\\\\Users\\\\Administrato...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40040008         DC32     0x40040008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40040004         DC32     0x40040004

   \                                 In section .rodata, align 4
   \                     `?<Constant "C:\\\\Users\\\\Administrato...">`:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x41          DC8 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H, 73H
   \              0x64 0x6D    
   \              0x69 0x6E    
   \              0x69 0x73    
   \   00000010   0x74 0x72          DC8 74H, 72H, 61H, 74H, 6FH, 72H, 5CH, 44H
   \              0x61 0x74    
   \              0x6F 0x72    
   \              0x5C 0x44    
   \   00000018   0x65 0x73          DC8 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH, 0D1H
   \              0x6B 0x74    
   \              0x6F 0x70    
   \              0x5C 0xD1    
   \   00000020   0xEE 0xCF          DC8 0EEH, 0CFH, 0F2H, 0BEH, 0FCH, 0B5H, 0C4H, 4BH
   \              0xF2 0xBE    
   \              0xFC 0xB5    
   \              0xC4 0x4B    
   \   00000028   0x36 0x30          DC8 36H, 30H, 0C4H, 0A3H, 0B0H, 0E5H, 5FH, 0D6H
   \              0xC4 0xA3    
   \              0xB0 0xE5    
   \              0x5F 0xD6    
   \   00000030   0xBB 0xD3          DC8 0BBH, 0D3H, 0D0H, 0BBH, 0F9H, 0B1H, 0BEH, 49H
   \              0xD0 0xBB    
   \              0xF9 0xB1    
   \              0xBE 0x49    
   \   00000038   0x4F 0xB2          DC8 4FH, 0B2H, 0D9H, 0D7H, 0F7H, 5CH, 73H, 72H
   \              0xD9 0xD7    
   \              0xF7 0x5C    
   \              0x73 0x72    
   \   00000040   0x63 0x5C          DC8 63H, 5CH, 64H, 72H, 69H, 76H, 65H, 72H
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \   00000048   0x73 0x5C          DC8 73H, 5CH, 6CH, 70H, 74H, 6DH, 72H, 5CH
   \              0x6C 0x70    
   \              0x74 0x6D    
   \              0x72 0x5C    
   \   00000050   0x6C 0x70          DC8 6CH, 70H, 74H, 6DH, 72H, 2EH, 63H, 0
   \              0x74 0x6D    
   \              0x72 0x2E    
   \              0x63 0x00    
    144          
    145          
    146          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  lptmr_counter_clean
       24  lptmr_counter_init
             24 -> assert_failed
        8  lptmr_irq_DIS
              8 -> disable_irq
        8  lptmr_irq_EN
              8 -> enable_irq
        0  time_delay_ms


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      88  ?<Constant "C:\\Users\\Administrato...">
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
      26  lptmr_counter_clean
     126  lptmr_counter_init
      22  lptmr_irq_DIS
      22  lptmr_irq_EN
      56  time_delay_ms

 
  88 bytes in section .rodata
 276 bytes in section .text
 
 276 bytes of CODE  memory
  88 bytes of CONST memory

Errors: none
Warnings: none
